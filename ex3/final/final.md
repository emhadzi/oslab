3η Εργαστηριακή Αναφορά
===

***Μανώλης Χατζηγεωργίου: el22082***

***Χρήστος Μπουκουβάλας: el22120***

## 1.1 Κλήσεις συστήματος και βασικοί μηχανισμοί του ΛΣ για τη διαχείριση της εικονικής μνήμης

1. Τυπώνουμε τον χάρτη μνήμης της διεργασίας
    <p align="center">
     <img src="1.png" alt="Description" width="450"/>
    </p>
  - Παρατηρούμε πως ο χώρος λογικών διευθύνσεων περιορίζεται σε 48 εκ των 64 bits. Αυτό οδηγεί σε μικρότερα page tables 
    ενώ βοηθάει στο διαχωρισμό μνήμης διεργασίας και kernel μέσω του sign extension.
  - Επίσης παρατηρούμε πως χρησιμοποιείται ASLR (Address Space Layout Randomization) για προστασία από gadget attacks. 
  - Παράλληλα βλέπουμε πως οι πρώτες σελίδες του χώρου λογικών διευθύνσεων δεν είναι έγκυρες ως προστασία από null pointer dereferences.

2. Με την κλήση συστήματος `mmap()` δεσμεύουμε buffer μεγέθους μίας σελίδας (page) και τυπώνουμε ξανά το χάρτη.
    <p align="center">
     <img src="2.png" alt="Description" width="450"/>
    </p>
  - Βλέπουμε πως έχει δημιουργηθεί ένα καινούργιο *anonymous* (not file backed) εύρος μεγέθους μίας σελίδας
   `7fb1ed337000-7fb1ed338000 rw-p 00000000 00:00 0`
    με δικαιώματα ανάγνωσης και εγγραφής *rw*. Το εύρος αυτό έχει επίσης την ιδιότητα protected *-p*, 
    δηλαδή αντιγράφεται μέσω του Copy On Write σε διεργασίες που το κληρονομούν.

3. Βρίσκουμε και τυπώνουμε τη φυσική διεύθυνση μνήμης στην οποία απεικονίζεται η εικονική διεύθυνση του buffer
    <div style="width: 450px; margin: auto; text-align: center;">
      <pre><code>VA[0x7fb1ed337000] is not mapped; no physical memory allocated.
   </code></pre>
    </div>
  - Παρατηρούμε πως δεν υπάρχει page entry το οποίο αντιστοιχεί τη λογική διεύθυνση του buffer σε φυσική.
    Αυτό είναι λογικό λόγω του demand paging, το οποίο δημιουργεί entries όταν γίνεται η πρώτη αναφορά στο page μνήμης.
    Η δημιουργία του buffer δεν προσμετράται ως αναφορά στη μνήμη (read - write) αλλά αλλάζει μόνο τον χάρτη μνήμης.

4. Γεμίζουμε με μηδενικά τον buffer και επαναλαμβάνουμε το βήμα 3
    <div style="width: 450px; margin: auto; text-align: center;">
      <pre><code>Physical address: 0x1149ca000</code></pre>
    </div>
  - Η πρώτη αναφορά στη μνήμη του buffer (εγγραφή πρώτης τιμής του σε 0) προκάλεσε page fault. Τότε το λειτουργικό
    ενεργοποιήθηκε, συμβουλεύτηκε τον χάρτη μνήμης και αφού επιβεβαίωσε την εγκυρότητα της αναφοράς δέσμευσε ένα page
    φυσικής μνήμης και δημιούργησε το αντίστοιχο entry στο page table, βάσει του demand paging που αναφέραμε παραπάνω.

5. Χρησιμοποιούμε τη `mmap()` για να απεικονίσουμε το αρχείο file.txt στον χώρο διευθύνσεων της διεργασίας και να τυπώνουμε το περιεχόμενό του.
   <p align="center">
     <img src="5.png" alt="Description" width="450"/>
   </p>
 - Παρατηρούμε πως στον χάρτη μνήμης δημιουργήθηκε ένα νέο *file backed* εύρος μεγέθους μίας σελίδας 
   `7fb1ed30d000-7fb1ed30e000 r--p 00000000 00:26 7491160                    /home/oslab/oslab104/ex3/1_1/file.txt
   `με δικαιώματα ανάγνωσης *r* και την ιδιότητα protected *-p*.

6. Χρησιμοποιούμε την `mmap()` για να δεσμεύσουμε έναν νέο buffer, διαμοιραζόμενο
   (shared) αυτή τη φορά μεταξύ διεργασιών με μέγεθος μιας σελίδας.
   <p align="center">
     <img src="6.png" alt="Description" width="450"/>
   </p>
 - Σε σύγκριση με την προηγούμενη εικόνα του χάρτη μνήμης εντοπίζουμε πως ο νέος *anonymus* buffer βρίσκεται στο εύρος 
   `7fb1ed30c000-7fb1ed30d000 rw-s 00000000 00:01 585                        /dev/zero (deleted)` και έχει δικαιώματα
   ανάγνωσης και εγγραφής. Παρατηρούμε πως δημιουργήθηκε με τη βοήθεια του αρχείου `/dev/zero`, οπότε αναμένουμε να είναι γεμάτος
   με bytes `\0`.

---

7. Τυπώνουμε τους χάρτες της εικονικής μνήμης της γονικής διεργασίας και της διεργασίας παιδιού
   <p align="center">
     <img src="7_1.png" alt="Description" width="450"/>
   </p>
   <p align="center">
     <img src="7_2.png" alt="Description" width="450"/>
   </p>
 - Παρατηρούμε πως δεν υπάρχει διαφορά ανάμεσα στους χάρτες μνήμης των δύο διεργασιών. Αυτό είναι λογικό αφού
   η `fork()` δημιουργεί αντίγραφο της διεργασίας η οποία την καλεί.

8. Βρίσκουμε και τυπώνουμε τη φυσική διεύθυνση στη κύρια μνήμη του private buffer του βήματος 3 για τις διεργασίες γονέα και παιδιού.
    <div style="width: 450px; margin: auto; text-align: center;">
    <pre><code>Printing parent's private buffer physical address.
    Physical address: 0x1149ca000
    
    Printing child's private buffer physical address.
    Physical address: 0x1149ca000</code></pre>
    </div>
 - Παρατηρούμε πως οι φυσικές διευθύνσεις είναι ίδιες παρόλο που ο buffer είναι shared (οπότε θα περιμέναμε να δημιουργηθεί αντίγραφο λόγω του `fork()`)
   Όμως λόγω του Copy On Write αυτές παραμένουν ίδιες, μέχρι κάποια από τις διεργασίες να εκτελέσει εγγραφή στον buffer, οπότε τότε εκτελείται αντιγραφή.

9. Γράφουμε στον private buffer από τη διεργασία παιδί και επαναλαμβάνουμε το βήμα 8
   <div style="width: 450px; margin: auto; text-align: center;">
   <pre><code>Printing parent's private buffer physical address.
   Physical address: 0x1149ca000
    
   Printing child's private buffer physical address.
   Physical address: 0x1149ca000</code></pre>
   </div>

 - Παρατηρούμε πως αφού υπήρξε εγγραφή, ενεργοποιήθηκε το Copy On Write και έτσι δημιουργήθηκε αντίγραφο του buffer στο παιδί, το οποίο έπειτα το τροποποίησε.
   Για αυτόν τον λόγο τώρα οι φυσικές διευθύνσεις διαφέρουν, αφού η μία δείχνει στον αρχικό buffer και η άλλη στο αντίγραφο.

10. Γράφουμε στον shared buffer του βήματος 6 από τη διεργασία παιδί και τυπώνουμε τη φυσική
    του διεύθυνση για τις διεργασίες γονέα και παιδιού.
   <div style="width: 450px; margin: auto; text-align: center;">
   <pre><code>Printing parents's shared buffer physical address.
   Physical address: 0x183255000

   Printing child's shared buffer physical address.
   Physical address: 0x183255000</code></pre>
   </div>

 - Παρατηρούμε πως σε αντίθεση με τον private buffer, η εγγραφή δεν ενεργοποίησε το Copy On Write.
   Αυτό είναι λογικό αφού ο παρών buffer είναι διαμοιραζόμενος (shared), άρα δεν αντιγράφεται μεταξύ των διεργασιών.

11. Απαγορεύουμε τις εγγραφές στον shared buffer για τη διεργασία παιδί.
   <p align="center">
     <img src="11.png" alt="Description" width="450"/>
   </p>

 - Επιβεβαιώνουμε την απαγόρευση βλέποντας πως το εύρος `7fb1ed30c000-7fb1ed30d000 r--s 00000000 00:01 585                        /dev/zero (deleted)`
   (shared buffer) έχει μόνο δικαιώματα ανάγνωσης *r*. 

12. Αποδεσμεύουμε όλους τους buffers στις δύο διεργασίες

## 1.2 Παράλληλος υπολογισμός Mandelbrot με διεργασίες αντί για νήματα

### 1.2.1 Semaphores πάνω από διαμοιραζόμενη μνήμη

Πρωτού δημιουργήσουμε τις διεργασίες, δημιουργούμε ένα τμήμα διαμοιραζόμενης μνήμης όπου και αρχικοποιούμε έναν πίνακα με `NPROC` σεμαφόρους. Οι σεμαφόροι αρχικά δεν επιτρέπουν εγγραφή σε καμοία διεργασία.

```c
// Create and initialize shared semaphore buffer
sem_buf_size = sizeof(sem_t)*NPROCS;
sem_buf = create_shared_memory_area(sem_buf_size);
for(int i = 0; i<NPROCS; ++i){
    if (sem_init(&sem_buf[i], 1, 0) != 0){
        perror("Failed semaphore initalization");
        exit(EXIT_FAILURE);
    }
}
```

Όπως έχουμε ξαναδεί σε προηγούμενες εργασίες, καλούμε τη `fork()` για να δημιουργήσουμε `NPROC` διεργασίες. Κάθε διεργασία υπολογίζει ένα τμήμα του Mandelbrot set.

```c
for(int line=0; line<lines; ++line)
    compute_mandel_line(id+line*NPROCS, output_buf[line]);
```

Έπειτα, για κάθε γραμμή, αφότου διασφαλίσει μέσω του κατάλληλου semaphore ότι είναι η σειρά της να τυπώθει, την τυπώνει στο τερματικό. Πλέον, μπορούμε να προχωρήσουμε στην εκτύπωση νέας γραμμής, για αυτό απελευθερώνουμε τον επόμενο σεμαφόρο.

```c
for(int line=0; line<lines; ++line){
    sem_wait(&sem_buf[id]);
    output_mandel_line(1,output_buf[line]);
    sem_post(&sem_buf[(id+1)%NPROCS]);
}
```

Σημειώνουμε ότι η διαδικάσια θα μπορούσε να υλοποιηθεί λίγο διαφορετικά για την εξοικονόμηση μνήμης, τυπώνοντας κάθε γραμμή μόλις την υπολογίζουμε.

```c
for(int line=0; line<lines; ++line){
    compute_mandel_line(id+line*NPROCS, output_buf);
    sem_wait(&sem_buf[id]);
    output_mandel_line(1,output_buf);
    sem_post(&sem_buf[(id+1)%NPROCS]);
}
```

Για να πυροδοτήσουμε την αλυσίδα υπολογισμού, αφότου δημιουργήσουμε τις διεργασίες, αρχικοποιούμε τον πρώτο σεμαφόρο ώστε να επιτρέψει την εκτύπωση της πρώτης γραμμής.

```c
// Start ordered output
sem_post(&sem_buf[0]);
```

Τέλος, η κύρια διεργασία περιμένει να ολοκληρωθούν όλες οι διεργασίες, αποδεσμεύει τη διαμοιραζόμενη μνήμη και επαναφέρει το χρώμα του τερματικού.

```c
// Wait for all children to finish
int status;
for(int i=0; i<NPROCS; ++i)
    waitpid(pids[i], &status, 0);

// Clean up
destroy_shared_memory_area(sem_buf,sem_buf_size);
reset_xterm_color(1);
```

#### Ερωτήσεις:

1. Ποια από τις δύο παραλληλοποιημένες υλοποιήσεις (threads vs processes) περιμένετε να έχει καλύτερη επίδοση και γιατί; Πώς επηρεάζει την επίδοση της υλοποίησης με διεργασίες το γεγονός ότι τα semaphores βρίσκονται σε διαμοιραζόμενη μνήμη μεταξύ διεργασιών;

Αναμένουμε η υλοποίηση με νήματα να έχει καλύτερη επίδοση, καθώς τα νήματα μοιράζονται την ίδια εικονική μνήμη και δεν απαιτείται η χρήση διαμοιραζόμενης μνήμης για τους σεμαφόρους. Πέριμένουμε αρχικά το overhead δημιουργίας κοινής μνήμης, δημιουργίας και ομαλού τερματισμού `NPROCS` διεργασιών να είναι μεγαλύτερο από την δημιουργία και εννοποιήση `NPROCS` threads. Επίσης, πίο σημαντικά, το κόστος context switch μεταξύ διεργασιών είναι μεγαλύτερο από το αντίστοιχο των νημάτων, καθώς οι διεργασίες έχουν ξεχωριστό χώρο διευθύνσεων και απαιτείται η αλλαγή του page table και καθαρισμός του TLB. Τέλος, επειδή διαφορετικά threads μοιράζονται την ίδια εικονική μνήμη, ενδέχεται το σύστημα διαχείρισης της cache να λειτουργεί πιο αποδοτικά.

2. Μπορεί το mmap() interface να χρησιμοποιηθεί για τον διαμοιρασμό μνήμης μεταξύ διεργασιών που δεν έχουν κοινό ancestor; Αν όχι, γιατί;

Το `mmap()` interface δεν μπορεί να χρησιμοποιηθεί για διαμοιρασμό μνήμης μεταξύ διεργασιών που δεν έχουν κοινό πρόγονο, τουλάχιστον όταν πρόκειται για ανώνυμες περιοχές μνήμης. Αυτό συμβαίνει επειδή οι ανώνυμες περιοχές που δημιουργούνται με `mmap()` (π.χ. με την παράμετρο `MAP_ANONYMOUS`) δεν σχετίζονται με κάποιο αντικείμενο στο σύστημα αρχείων και είναι προσβάσιμες μόνο μέσω του page table της τρέχουσας διεργασίας, επομένως, δεν μπορούν να γίνουν προσβάσιμες από ανεξάρτητες διεργασίες. Για να επιτευχθεί διαμοιρασμός μνήμης μεταξύ ξένων διεργασιών, είναι απαραίτητο να χρησιμοποιηθεί ένα αρχείο ώστε το `mmap()` να χαρτογραφήσει την ίδια φυσική περιοχή μνήμης στον χώρο διευθύνσεων κάθε συμμετέχουσας διεργασίας.

### 1.2.2 Υλοποίηση χωρίς semaphores

Η υλοποίηση βρίσκεται στο αρχείο `mandelbrot_no_semaphores.c`. Οι διεργασίες-παιδιά είναι υπεύθυνες μόνο για τον υπολογισμό των γραμμών του Mandelbrot set και την αποθήκευση τους σε κοινό buffer. Έπειτα, ο γονέας τυπώνει τις αποτελέσματα στο τερματικό με την σωστή σειρά. 

1. Με ποιο τρόπο και σε ποιο σημείο επιτυγχάνεται ο συγχρονισμός σε αυτή την υλοποίηση; Πώς θα επηρεαζόταν το σχήμα συγχρονισμού αν ο buffer είχε διαστάσεις `NPROCS x x_chars`;

Ο μόνος συγχρονισμός που απαιτείται είναι ο γονέας να ξεκινάει την εκτύπωση αφότου όλες οι διεργασίες έχουν ολοκληρώσει τον υπολογισμό τους. Αυτό επιτυγχάνεται με την αναμονή του τερματισμού όλων των διεργασιών μέσω της `waitpid()`. Από εκεί και πέρα, υπάρχει σειριοποίηση στην εκτύπωση των γραμμών, αφού την λειτουργία αυτή την αναλαμβάνει μόνο ο γονέας.

Στην περίπωση που ο buffer είχε διαστάσεις `NPROCS x x_chars`, κάθε παιδί αναλαμβάνει να υπολογίσει και να αποθηκεύσει μία γραμμή του Mandelbrot set στον κοινό buffer. Σε αυτή την περίπτωση, ο γονέας θα μπορούσε να τυπώνει τις γραμμές με την σειρά που μαζεύει τα παιδιά, χωρίς να χρειάζεται να περιμένει για όλα να ολοκληρώσουν.

```c
for(int i=0; i<NPROCS; ++i){
    waitpid(pids[i], &status, 0);
    output_mandel_line(1, &shared_buf[x_chars * i]);
}
```

## 1.3 Επέκταση Άσκησης 1

Εγκαθιστούμε έναν signal handler ο οποίος κλειδώνει τον κοινό πόρο `shared_memory_counter` και τον εκτυπώνει στη λήψη του σήματος *SIGINT*.
```c
void sigint_handler(int sig) {
        sem_wait(sem);
        printf("Found %d occurences of character %c.\n", *shared_counter_ptr, target);
        exit(0);
        sem_post(sem);
}
```
```c
struct sigaction sa;
        sa.sa_handler = sigint_handler;
        sa.sa_flags = 0;
        sigemptyset(&sa.sa_mask);
        if (sigaction(SIGINT, &sa, NULL) == -1) {
                perror("sigaction");
                exit(EXIT_FAILURE);
        }
```

Τώρα αρκεί να κλειδώσουμε τον κοινό πόρο και σε κάθε εύρεση του χαρακτήρα.

```c
while(sz > 0){
                int read_sz = read(fd, buff, min(sz, CHUNK_SZ));
                for(int i = 0; i < read_sz; i++)
                        if(buff[i] == target)
                                res++;
                sz -= read_sz;
                sem_wait(sem);
                *shared_counter_ptr += res;
                sem_post(sem);
        }
```

Ας σημειωθεί πως αφού ο πόρος είναι απλός ακέραιος, θα αρκούσε αντί για κλείδωμα η εντολή *atomic add*.
