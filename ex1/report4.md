## 4) Εφαρμογή παράλληλης καταμέτρησης χαρακτήρων

### worker.c

Ο πυρήνας του αρχείου worker.c για την καταμέτρηση χαρακτήρα σε ένα διάστημα βασίζεται στην άσκηση *1.3*. 

Σχετικά με την επικοινωνία του με τον πατέρα/dispatcher:

Θέλουμε ο κώδικας του worker.c να εκτελείται μετά την χρήση `execv()`, για αυτό η συνάρτηση main χρειάστηκε να δέχεται τις εξής 6 παραμέτρους
 
- Το worker id του (μπορεί να παραλειφθεί)
- Το όνομα του αρχείου που θέλουμε να διαβάσουμε 
- Την θέση του πρώτου byte που θέλουμε να επεξεργαστούμε
- Την θέση του τελευταίου byte
- Τον χαρακτήρα που μετράμε
- Το file descriptor του pipe όπου θα γράψουμε το αποτέλεσμα

Για την επικοινωνία μεταξύ των workers και του dispatcher αποφασίσαμε να χρησιμοποιήσουμε ένα ξεχωριστό pipe για κάθε worker. Ο εργάτης θα στέλνει μέσω αυτού το τελικό αποτέλεσμα αλλά και οποιδήποτε ενδιάμεσο αποτέλεσμα όταν του ζητηθεί.

Αποφύγαμε την χρήση κοινού pipe για την εγγραφή διότι:
- Είναι λίγο πιο δύσκολο να καταλάβουμε από ποιόν worker προήλθε το κάθε αποτέλεσμα
- Είχαμε ανησυχίες για την εμφάνηση συνθήκων συναγωνισμού όταν δύο εργάτες προσπαθούν ταυτόχρονα να γράψουν στο κοινό pipe (Αργότερα μάθαμε ότι εφαρμόζονται κατάλληλα κλειδώματα ώστε να μην εμφανίζεται αυτό το πρόβλημα)

Το κύριο πλεονέκτημα χρήσης κοινού pipe είναι ότι αυξάνεται σημαντικά ο αριθμός των μέγιστων εργατών που μπορούν να χρησιμοποιηθούν. Σε αυτή την έκδοση ο μέγιστος αριθμός εργατών είναι περίπου 1000 λόγω του ορίου στον αριθμό ανοιχτών file descriptor.

Για να μην είναι απαραίτητη η τελευταία παράμετρος χρησιμοποιήσαμε πρωτού εκτελέσουμε execv() την εντολή `dup2(workHead->pipefd[1], STDOUT_FILENO);` η οποία αντικαθηστά το stdout του αρχείου με το fd του κατάλληλου pipe. Προσέχουμε να μην χρησιμοποιούμε πλέον το stdout για την αναφορά λαθών

Για την αναφορά ενδιάμεσων αποτελεσμάτων χρησιμοποιήσαμε σήματα από τον dispatcher στους workers. Όταν ένας worker δεχτεί σήμα `SIGUSR1` σταματάει για λίγο να επεξεργάζεται χαρακτήρες και στέλνει 2 ακεραίους στον σωλήνα του: `write_to_pipe(cur-1, cnt);`

- Την θέση του τελευταίου byte που έχει ελέγξει
- Το πλήθος των χαρακτήρων που έχουν βρεθεί ως τώρα

Τέλος, ο αφότου τελειώσει την δουλεία του, ο εργάτης στέλνει μια τελική αναφορά `write_to_pipe(endPos, cnt);`

### dispatcher.c

Κύριος ρόλος του dispatcher είναι ο αποδοτικός διαμοιρασμός της συνολικής δουλειάς. Το πρόβλημα της προσέγγισης που χρησιμοποιήσαμε στην άσκηση *1.3* είναι ότι δεν είναι δυναμική, δηλαδή δεν υποστηρίζει κατάλληλα την προσθήκη και αφαίρεση εργατών.

Η λογική που τελικά ακολουθήσαμε είναι: Αν δεν έχει προκύψει κάποιο πρόβλημα αναθέτουμε σε έναν εργάτη που δεν έχει δουλειά το πρώτο διαθέσιμο κομμάτι μεγέθους `normalWLoad` bytes (πολλαπλάσιο του `CHUNK_SIZE`). Διατηρούμε λοιπόν ένα σύνορο (`front`) δεξιά του οποίου δεν εργάζεται κανένας worker ώστε όταν ελευθερωθεί κάποιος να αναλάβει το διάστημα `[front, front+normalWLoad-1]`. 

Αν όμως κάποιος εργάτης αποτύχει, δημιουργείται μία "τρύπα" στην επεξεργασία του αρχείου την οποία χρειάζεται να γεμίσει ο επόμενος εργάτης. Έλεγχουμε λοιπόν κατάλληλα για κάθε εργάτη αν έχει τερματίσει, αν τερμάτισε πρωτού τυπώσει το τελικό του αποτέλεσμα, κάτι πήγε στραβά, για αυτό κοιτάμε την τελευταία αναφορά που δεχτήκαμε από τον εργάτη (αν υπάρχει) και αποθηκεύουμε το διάστημα για το οποίο δεν έχει ενημερωθεί ο dispatcher, ώστε να το αναλάβει κάποιος επόμενος εργάτης

Αποφασίσαμε να χρησιμοποιήσουμε διπλά συνδεδεμένες λίστες για την αποθήκευση των εργατών που (απ'όσο ξέρει ο dispatcher) αυτή την στιγμή δουλεύουν και για τα διαστήματα που χρωστάμε να αναπληρώσουμε

Εκ των υστέρων, η επιλογή doubly linked list έναντι ενός στατικού array με κάποια μέγιστη χωρητικότητα ίσως ήταν υπερβολική αφού λόγω του ορίου στον μέγιστο αριθμό pipes, δεν μπορούμε να χρησιμοποιησουμε περισσότερους από 1000 εργάτες. Ωστόσο η υλοποιησή με linked list είναι αρκετά πιο ευέλικτη αφου μπορεί να υποστηρίξει αποδοτικά περισσότερους εργάτες αν αυξηθεί το μέγιστο όριο.

Για τον συνεχόμενο έλεγχο των εργατών και των σωλήνων τους από τον dispatcher χρησιμοποιήσαμε **non-blocking** `pid_t p = waitpid(cur->pid, &status, WNOHANG);`  και `read()`: με την εντολή `fcntl(workHead->pipefd[0], F_SETFL, O_NONBLOCK);` μετά την δημιουργία κάθε pipe. Ο έλεγχος εκτελείται σε ένα loop που τερματίζει μόνο όταν ολοκληρωθεί η επεξεργασία του αρχείου `while(proc < fileSz || workerCount > 0)`

Για την λήψη εντολών από το frontend: Στον κεντρικό βρόγχο ελέγχεται επίσης με non-blocking read() αν εκρεμεί κάποια εντολή από τον frontend `while(read(STDIN_FILENO, req, sizeof(req)) > 0)`

- Για την προσθήκη n εργατών: Καλείται n φορές η συνάρτηση `createWorker()` η οποία αν υπάρχει δουλειά να ανατεθεί και αν δεν υπερβαίνουμε τον μέγιστο αριθμό εργατών, κοιτάμε αν υπάρχει καποιο κενό που χρειάζεται να γεμίσουμε αλλιώς


O dispatcher δεν χρειάζεται να ειναι αποδοτικός