#  2η Εργαστηριακή Άσκηση

## Ζητούμενο 1

Δημιουργούμε μία διεργασία παιδί που χαιρετάει τον κόσμο αναφέροντας το αναγνωριστικό της και το αναγνωριστικό του γονέα της. Ο γονέας τυπώνει το αναγνωριστικό του παιδιού και περιμένει τον τερματισμό του.

### Δημιουργία παιδιού από τον γονέα

```c
pid_t p = fork();
if(p < 0){
    printf("Error creating process\n");
    return -1;
}
```
Με την εντολή fork() ζητούμε από το λειτουργικό να κλονοποιήσει την τρέχουσα διεργασία (γονέα), δημιουργώντας ένα πλήρες αντίγραφό της στην μνήμη (παιδί). Η μόνη διαφορά μεταξύ των δύο διεργασιών είναι η τιμή επιστροφής της fork(), η οποία στη διεργασία γονέα αντιστοιχεί στο pid του παιδιού και στο παιδί αντιστοιχεί σε 0. Αν για κάποιον λόγο το παιδί δεν δημιουργηθεί, η fork επιστρέφει -1 στον γονέα, το οποίο διαχειριζόμαστε ενημερώνοντας τον χρήστη για το σφάλμα κα τερματίζοντας.

Σημείωση: Στην πραγματικότητα η αντιγραφή της διεργασίας ακολουθεί τον κανόνα copy-on-write, δηλαδή αντιγράφονται δεδομενά μόνο όταν αυτά διαφοροποιηθούν (γραφτούν)
ανάμεσα στις διεργασίες. Ο κώδικας, για παράδειγμα, που είναι read-only, διατηρείται κοινός, απλά κάθε διεργασία έχει διαφορετικό program counter.

### Αν βρισκόμαστε στο παιδί (fork επιστρέφει 0)

```c
else if(p == 0){
		pid_t child_pid = getpid();
		pid_t parent_pid = getppid();
		printf("Hello, i am the child process with pid: %ld, my parent is %ld\n"
			, child_pid, parent_pid);
```

Αν βρισκόμαστε στο παιδί, βρίσκουμε το αναγνωριστικό μας και του γονέα μας και στη συνέχεια χαιρετάμε τον κόσμο εκτυπώνοντας αυτές τις τιμές. Για την εύρεση του αναγνωριστικού της τρέχουσας διεργασίας (παιδί) χρησιμοποιούμε την κλήση συστήματος getpid(), ενώ για την εύρεση του αναγνωριστικού του γονέα χρησιμοποιούμε την κλήση συστήματος getppid().

### Αν βρισκόμαστε στο παιδί (fork επιστρέφει το pid του παιδιού)

```c
else{
		printf("My child's pid is: %ld\n", p);
		int wstatus;
		pid_t done = wait(&wstatus);
		printf("Child terminated with: %ld\n", wstatus);
		exit(1);
	}
```
Αν βρισκόμαστε στον γονέα, τυπώνουμε το αναγνωριστικό του παιδιού και περιμένουμε τον τερματισμό του. Εφόσον γνωρίζουμε ήδη το pid του παιδιού μέσω της fork, αρκεί να περιμένουμε τον τερματισμό του χρησιμοποιώντας την κλήση συστήματος wait(&status), η οποία μπλοκάρει την εκτέλεση του γονέα μέχρι οποιαδήποτε διεργασία-παιδί να τερματήσει. Η τιμή επιστροφής της wait αντιστοιχεί στο pid του παιδιού που τερμάτισε, ενώ το status λαμβάνει την τιμή επιστροφής του παιδιού (πχ -1 αν το παιδί κάλεσε exit(-1)).

## Ζητούμενο 2

Ορίζουμε μια μεταβλητή  x στο γονέα πριν τη δημιουργία του παιδιού.
Αναθέτουμε διαφορετική τιμή στο γονέα και στο παιδί και την τυπώνουμε.

```c
    int x;
    pid_t p = fork();
    if(p < 0){
        printf("Error creating process\n");
        return -1;
    }
    else if(p == 0){
        x = 10;
        printf("x = %i, at child process\n", x);
    }
    else{
        x = 20;
        printf("x = %i, at parent process\n", x);
    }

```
Παρατηρούμε πως:
- Η μεταβλητή x δεν είναι κοινή μεταξύ των διεργασιών, δηλαδή πάντα το παιδί εκτυπώνει 10 και ο γονέας 20. Αυτό είναι λογικό εφόσον γράφοντας στο x, εκτελούμε το copy-on-write, δηλαδή δημιουργούμε ξεχωριστά αντίγραφα του x σε κάθε διεργασία τα οποία δεν αλληλεπιδρούν μεταξύ τους.
- Η σειρά εκτύπωσης των x δεν είναι πάντα η ίδια. Αυτό είναι επίσης λογικό εφόσον έχοντας δημιουργήσει δύο διεργασίες, αφήνουμε στον δρομολογητή να επιλέξει τη σειρά εκτέλεσης των εκτυπώσεων, η οποία είναι "τυχαία".

## Ζητούμενα 3-4

Αναθέτουμε στη διεργασία παιδί την αναζήτηση ένος χαρακτήρα σε αρχείο. Το πετυχαίνουμε αυτό χρησιμοποιώντας τον κώδικα του Ερωτήματος 1. Για να μη χρειαστεί να τον αντιγράψουμε ολοκλήρο με το χέρι μέσα στον κώδικα του παιδιού (block όπου η fork επιστρέφει 0), χρησιμοποιούμε την κλήση συστήματος execv.
Αυτή είναι μια πολύ χρήσιμη εντολή η οποία επεγγράφει τον κώδικα μιας διεργασίας με έναν οποιοδήποτε εκτελέσιμο κώδικα τον οποίο έχουμε αποθηκευμένο στον δίσκο. Έτσι μπορούμε να επαναχρησιμοποιούμε κώδικα σε διαφορετικές διεργασίες χωρίς να γράφουμε τεράστια μονολιθικά προγράμματα.

### Αν βρισκόμαστε στο παιδί (fork επιστρέφει 0)

```c
	else if(p == 0){
		char* args[] = {"a1.1-system_calls", "fin.txt", "fout.txt", "a", NULL};
		if(execv("./a1.1-system_calls", args) == -1){
			printf("Error loading exec\n");
			return -1; 
		}
	}
```

Αν βρισκόμαστε στο παιδί, αντικαθιστούμε τον κώδικά του με το εκτελέσιμο με όνομα "a1.1-system_calls" στο current working directory. Ο πίνακας args (NULL terminated) περιέχει τα ορίσματα του προγράμματος το οποίο θέλουμε φορτώσουμε στη διεργασία (όπως αυτό θα καλλούνταν από έναν φλοιό), δηλαδή τις παραμέτρους της συνάρτησης main του.
Αν η execv αποτύχει, ενημερώνουμε τον χρήστη και τερματίζουμε. Αλλίως αναζητούμε τον χαρακτήρα όπως στο Ερώτημα 1.

Σημείωση: Με αυτήν την υλοποίηση το παιδί διαχειρίζεται μόνο του τα αρχεία ανοίγοντας και κλείνοντάς τα μέσα στον κώδικα του a1.1-system-calls. Αν θέλαμε μόνο ο γονέας να διαχειρίζεται τα αρχεία, θα έπρεπε να τα ανοίξουμε πριν κάνουμε fork και execv, και να τα κλείσουμε όταν το παιδί τερματίσει. Αφού οι file descriptors διαχειρίζονται από το λειτουργικό, παραμένουν σε ισχύ είτε κάνουμε fork είτε execv. Στο fork θα μπορούσαμε να τους χρησιμοποίησουμε κατευθείαν εφόσουν θα έχουμε πάντα ένα αντίγραφό τους, στην execv έπρεπε απλά να τους περάσουμε σαν όρισμα στον πίνακα args.
Με αυτόν τον τρόπο μόνο ο γονέας θα διαχειριζόταν τα αρχεία.
