#  1η Εργαστηριακή Άσκηση
## 1) Ανάγνωση και εγγραφή αρχείων στη C και με τη βοήθεια κλήσεων συστήματος
Στο πρώτο μέρος της άσκησης ζητείται να υλοποιήσουμε πρόγραμμα `a1.1-system_calls.c` με την ίδια λειτουργικότητα του `a1.1-C.c` χωρίς την χρήση συναρτήσεων για επεξεργασία αρχείου από την `stdio.h`. 

Να σημειωθεί πως για την εκτύπωση πιθανών λαθών θεωρήσαμε αποδεκτή την χρήση της `printf()`  

### Έλεγχος παραμέτρων
Αν και δεν υποστηρίζεται από το `a1.1-C.c` προσθέσαμε τον παρακάτω στοιχειώδη έλεγχο:
```c
if(argc != 4 && argc != 5){
    printf("Incorrect number of arguments provided\n");
    return -1;
}
```
```c
if(strlen(argv[3]) > 1){
    printf("Program does not support matching >1 character\n");
    return -1;
}
```
### Άνοιγμα και κλείσιμο αρχείων
Για να ανοίξουμε το αρχείο εισόδου καλούμε την `int fdr = open(argv[1], O_RDONLY | O_CREAT, 0666);`

Αν το αρχείο υπάρχει, η συνάρτηση επιστρέφει έναν _file descriptor_ τον οποίο θα χρησιμοποιήσουμε αργότερα μόνο για να διαβάσουμε από αυτό (`O_RDONLY`)

Διαφορετικά, λόγω του _flag_ `O_CREAT`, ο _file descriptor_ θα αναφέρεται σε ένα νέο άδειο αρχείο με το ίδιο όνομα. Το νέο αρχείο θα έχει τα επιθυμητά permissions `-rw-rw-rw-` που προσδιορίζει το τελευταίο όρισμα `0666`

Αντίστοιχα για το αρχείο εξόδου: `int fdw = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0666);`

Αν το αρχείο υπάρχει, η συνάρτηση επιστρέφει έναν _file descriptor_ τον οποίο χρησιμοποιούμε μόνο για να γράψουμε σε αυτό (`O_RDONLY`)

Λόγω του _flag_ `O_CREAT`, αν το αρχείο δεν είναι κενό, τα περιεχόμενα του θα σβηστούν

Αν το αρχείο δεν υπάρχει, λόγω του _flag_ `O_CREAT` και του τρίτου ορίσματος `0666`, ο _file descriptor_ θα αναφέρεται σε ένα νέο άδειο αρχείο με το ίδιο όνομα, με permissions `-rw-rw-rw-` 

Σε περίπτωση πιθανού λάθους κατά την εκτέλεση της `open()` επιστρέφεται `-1`. Ελέγχουμε και χηριζόμαστε κατάλληλα αυτή την περίπτωση όπως φαίνεται παρακάτω 

```c
if(fdr < 0){
    printf("Problem opening file: %s to read\n", argv[1]);
    return -1;
}
```

Αργότερα, για να κλείσουμε τα ανοιχτά αρχεία καλούμε `close(fdr)` και `close(fdw)`

### Ανάγνωση από αρχείου εισόδου

Για να διαβάσουμε από το αρχείο που προηγουμένως ανοίξαμε χρησιμοποιούμε την κλήση συστήματος `read()`. Συγκεκριμένα η εντολή: `read_sz = read(fdr, buff, batch_sz);`
- Δέχεται ως πρώτο όρισμα τον _file descriptor_ `fdr` που αντιστοιχεί στο αρχείο εισόδου
- Δέχεται ως δεύτερο όρισμα έναν πίνακα από χαρακτήρες `buff` όπου θα αποθηκευτούν τα bytes που διαβάζονται
- Δέχεται ως τρίτο όρισμα το πλήθος bytes που θα θέλαμε να διαβαστούν `batch_sz`. Σε περίπτωση που μέχρι το τέλος του αρχείου υπάρχουν λιγότερα bytes από όσα ζητήσαμε θα διαβαστούν όλα μέχρι το τέλος του χωρίς πρόβλημα
- Επιστρέφει το πλήθος bytes που πραγματικά διαβάστηκε `read_sz`

O `fdr` αντιστοιχίζεται με έναν δείκτη που δείχνει σε κάποιο byte του αρχείου. Αμέσως αφου ανοίξουμε το αρχείο αυτός δείχνει στο πρώτο byte. Κάθε φορά που εκτελείται η παραπάνω εντολή ο δείκτης προχωράει μπροστά `read_sz` bytes

Συνεπώς, για να διαβάζουμε όλο το αρχείο, μπορούμε να το επεξεργαζόμαστε σε κομμάτια μεγέθους `batch_sz`. Με αυτόν τον τρόπο, ο buffer που χρειαζόμαστε αρκεί να έχει επίσης μέγεθος `batch_sz` 

```c
char buff[batch_sz];
```

Έχοντας τοποθετήσει τα περιεχόμενα του τρέχοντος κομματιού στον `buff`, εύκολα τον διατρέχουμε για να μετρήσουμε τις εμφανίσεις του ζητούμενου χαρακτήρα

Μπορούμε να αντιληφθούμε ότι έχουμε φτάσει στο τέλος του αρχείου αν `read_sz != batch_sz`

```c
do{
    read_sz = read(fdr, buff, batch_sz);
    for(int i = 0; i < read_sz; i++)
        cnt += buff[i] == argv[3][0];
}while(read_sz == batch_sz);
```

Θα μπορούσαμε για έλεγχο λάθους κατά την ανάγνωση να προσθέσουμε:

```c
if(read_sz < 0){
    printf("Problem reading from file %s\n", argv[1]);
    return -1;
}
```

Επειδή θέλαμε να μπορούμε εύκολα να μεταβάλλουμε το μέγεθος των κομματιών που χρησιμοποιούμε για ανάγνωση, ορίσαμε ως πέμπτο, προαιρετικό όρισμα της `main` το `batch_sz`. Ως default τιμή του ορίσαμε τα 1024 bytes

```c
const int batch_sz = (argv[4] == NULL ? 1024 : atoi(argv[4]));
```

Δοκιμάζοντας διαφορετικές τιμές για το μέγεθος του buffer πήραμε τους εξής χρόνους εκτέλεσης:

<div style="text-align: center;">
  <img src="batchTimes.png" width="30%">
</div>

Μέχρι κάποιο μέγεθος η αύξηση του `batch_sz` μειώνει τον χρόνο εκτέλεσης. Αυτό είναι λογικό εφόσον μειώνονται οι κλήσεις συστήματος (λόγω του `read()`) και άρα μειώνεται ο χρόνος `sys`. Επίσης βλέπουμε πως μειώνεται και ο χρόνος `user`, γεγονός το οποίο είναι περίεργο εφόσον τελούνται οι ίδιοι αριθμοί συγκρίσεων-πράξεων ανεξαρτήτως του `batch_sz`. Όμως κανείς πρέπει να σκεφτεί πως για μεγαλύτερο `batch_sz` έχουμε μεγαλύτερο `buffer`, επομένως και καλύτερο `cache locality`, τόσο επειδή επειδή οι τιμές που διαβάζουμε βρίσκονται σε γειτονικές θέσης μνήμης (`spatial locality`) όσο επειδή πραγματοποιούμε περισσότερες αναγνώσεις από τον `buffer` πριν η λειτουργία του προγράμματος μεταφερθεί στο λειτουργικό μέσω μιας κλήσης (`temporal locality`).  

### Εκτύπωση σε αρχείο εξόδου

Για την εκτύπωση στο αρχείο εξόδου χρησιμοποιούμε την κλήση συστήματος `write()`. Συγκεκριμένα η εντολή: `int written = write(fdw, msg, write_sz);`
- Δέχεται ως πρώτο όρισμα τον _file descriptor_ `fdw` που αντιστοιχεί στο αρχείο εξόδου
- Δέχεται ως δεύτερο όρισμα έναν πίνακα από χαρακτήρες `msg` του οποίου τα bytes θα γραφτούν
- Δέχεται ως τρίτο όρισμα το πλήθος bytes που θα θέλαμε να γραφτούν `write_sz`
- Επιστρέφει το πλήθος bytes που πραγματικά γράφτηκε `written`

Για να μορφοποιήσουμε το μήνυμα σε buffer χρησιμοποιούμε την συνάρτηση `snprintf()` (θεωρήσαμε την χρήση της επιτρεπτή επειδή δεν αφορά πρόσβαση σε αρχεία αλλά μορφοποίηση συμβολοσειράς στη μνήμη)

```c
char msg[128]; //problem when msg has more than 128 characters
int write_sz = snprintf(msg, sizeof(msg) , "The character '%c' appears %d times in file %s.\n", argv[3][0], cnt, argv[1]);
```

Αν το μήνυμα ξεπερνά τους 128 χαρακτήρες (αν το όνομα του αρχείου εξόδου είναι πάρα πολύ μεγάλο), υπάρχει κίνδυνος _truncation_. Μπορούμε να χειριστούμε τον κίνδυνο ως εξής:

```c
if(write_sz >= sizeof(msg)){
    printf("Message does not fit in buffer\n");
    return -1;
}
```
#  2η Εργαστηριακή Άσκηση

## Ζητούμενο 1

Δημιουργούμε μία διεργασία παιδί που χαιρετάει τον κόσμο αναφέροντας το αναγνωριστικό της και το αναγνωριστικό του γονέα της. Ο γονέας τυπώνει το αναγνωριστικό του παιδιού και περιμένει τον τερματισμό του.

### Δημιουργία παιδιού από τον γονέα

```c
pid_t p = fork();
if(p < 0){
    printf("Error creating process\n");
    return -1;
}
```
Με την εντολή fork() ζητούμε από το λειτουργικό να κλονοποιήσει την τρέχουσα διεργασία (γονέα), δημιουργώντας ένα πλήρες αντίγραφό της στην μνήμη (παιδί). Η μόνη διαφορά μεταξύ των δύο διεργασιών είναι η τιμή επιστροφής της fork(), η οποία στη διεργασία γονέα αντιστοιχεί στο pid του παιδιού και στο παιδί αντιστοιχεί σε 0. Αν για κάποιον λόγο το παιδί δεν δημιουργηθεί, η fork επιστρέφει -1 στον γονέα, το οποίο διαχειριζόμαστε ενημερώνοντας τον χρήστη για το σφάλμα και τερματίζοντας.

Σημείωση: Στην πραγματικότητα η αντιγραφή της διεργασίας ακολουθεί τον κανόνα copy-on-write, δηλαδή αντιγράφονται δεδομενά μόνο όταν αυτά διαφοροποιηθούν (γραφτούν)
ανάμεσα στις διεργασίες. Ο κώδικας, για παράδειγμα, που είναι read-only, διατηρείται κοινός, απλά κάθε διεργασία έχει διαφορετικό program counter.

### Αν βρισκόμαστε στο παιδί (fork επιστρέφει 0)

```c
else if(p == 0){
	pid_t child_pid = getpid();
	pid_t parent_pid = getppid();
	printf("Hello, i am the child process with pid: %ld, my parent is %ld\n", child_pid, parent_pid);
```

Αν βρισκόμαστε στο παιδί, βρίσκουμε το αναγνωριστικό μας και του γονέα μας και στη συνέχεια χαιρετάμε τον κόσμο εκτυπώνοντας αυτές τις τιμές. Για την εύρεση του αναγνωριστικού της τρέχουσας διεργασίας (παιδί) χρησιμοποιούμε την κλήση συστήματος getpid(), ενώ για την εύρεση του αναγνωριστικού του γονέα χρησιμοποιούμε την κλήση συστήματος getppid().

### Αν βρισκόμαστε στο γονέα (fork επιστρέφει το pid του παιδιού)

```c
else{
	printf("My child's pid is: %ld\n", p);
	int wstatus;
	pid_t done = wait(&wstatus);
	printf("Child terminated with: %ld\n", wstatus);
	exit(1);
}
```
Αν βρισκόμαστε στον γονέα, τυπώνουμε το αναγνωριστικό του παιδιού και περιμένουμε τον τερματισμό του. Εφόσον γνωρίζουμε ήδη το pid του παιδιού μέσω της fork, αρκεί να περιμένουμε τον τερματισμό του χρησιμοποιώντας την κλήση συστήματος wait(&status), η οποία μπλοκάρει την εκτέλεση του γονέα μέχρι οποιαδήποτε διεργασία-παιδί να τερματήσει. Η τιμή επιστροφής της wait αντιστοιχεί στο pid του παιδιού που τερμάτισε, ενώ το status λαμβάνει την τιμή επιστροφής του παιδιού (πχ -1 αν το παιδί κάλεσε exit(-1)).

## Ζητούμενο 2

Ορίζουμε μια μεταβλητή x στο γονέα πριν τη δημιουργία του παιδιού.
Αναθέτουμε διαφορετική τιμή στο γονέα και στο παιδί και την τυπώνουμε.

```c
    int x;
    pid_t p = fork();
    if(p < 0){
        printf("Error creating process\n");
        return -1;
    }
    else if(p == 0){
        x = 10;
        printf("x = %i, at child process\n", x);
    }
    else{
        x = 20;
        printf("x = %i, at parent process\n", x);
    }

```
Παρατηρούμε πως:
- Η μεταβλητή x δεν είναι κοινή μεταξύ των διεργασιών, δηλαδή πάντα το παιδί εκτυπώνει 10 και ο γονέας 20. Αυτό είναι λογικό εφόσον γράφοντας στο x, εκτελούμε το copy-on-write, δηλαδή δημιουργούμε ξεχωριστά αντίγραφα του x σε κάθε διεργασία τα οποία δεν αλληλεπιδρούν μεταξύ τους.
- Η σειρά εκτύπωσης των x δεν είναι πάντα η ίδια. Αυτό είναι επίσης λογικό εφόσον έχοντας δημιουργήσει δύο διεργασίες, αφήνουμε στον δρομολογητή να επιλέξει τη σειρά εκτέλεσης των εκτυπώσεων, η οποία είναι "τυχαία".

## Ζητούμενα 3-4

Αναθέτουμε στη διεργασία παιδί την αναζήτηση ένος χαρακτήρα σε αρχείο. Το πετυχαίνουμε αυτό χρησιμοποιώντας τον κώδικα του Ερωτήματος 1. Για να μη χρειαστεί να τον αντιγράψουμε ολοκλήρο με το χέρι μέσα στον κώδικα του παιδιού (block όπου η fork επιστρέφει 0), χρησιμοποιούμε την κλήση συστήματος execv.
Αυτή είναι μια πολύ χρήσιμη εντολή η οποία επεγγράφει τον κώδικα μιας διεργασίας με έναν οποιοδήποτε εκτελέσιμο κώδικα τον οποίο έχουμε αποθηκευμένο στον δίσκο. Έτσι μπορούμε να επαναχρησιμοποιούμε κώδικα σε διαφορετικές διεργασίες χωρίς να γράφουμε τεράστια μονολιθικά προγράμματα.

### Αν βρισκόμαστε στο παιδί (fork επιστρέφει 0)

```c
	else if(p == 0){
		char* args[] = {"a1.1-system_calls", "fin.txt", "fout.txt", "a", NULL};
		if(execv("./a1.1-system_calls", args) == -1){
			printf("Error loading exec\n");
			return -1; 
		}
	}
```

Αν βρισκόμαστε στο παιδί, αντικαθιστούμε τον κώδικά του με το εκτελέσιμο με όνομα "a1.1-system_calls" στο current working directory. Ο πίνακας args (NULL terminated) περιέχει τα ορίσματα του προγράμματος το οποίο θέλουμε φορτώσουμε στη διεργασία (όπως αυτό θα καλλούνταν από έναν φλοιό), δηλαδή τις παραμέτρους της συνάρτησης main του.
Αν η execv αποτύχει, ενημερώνουμε τον χρήστη και τερματίζουμε. Αλλιώς αναζητούμε τον χαρακτήρα όπως στο Ερώτημα 1.

Σημείωση: Με αυτήν την υλοποίηση το παιδί διαχειρίζεται μόνο του τα αρχεία ανοίγοντας και κλείνοντάς τα μέσα στον κώδικα του a1.1-system-calls. Αν θέλαμε μόνο ο γονέας να διαχειρίζεται τα αρχεία, θα έπρεπε να τα ανοίξουμε πριν κάνουμε fork και execv, και να τα κλείσουμε όταν το παιδί τερματίσει. Αφού οι file descriptors διαχειρίζονται από το λειτουργικό, παραμένουν σε ισχύ είτε κάνουμε fork είτε execv. Στο σκέτο fork θα μπορούσαμε να τους χρησιμοποίησουμε κατευθείαν εφόσουν θα έχουμε πάντα ένα αντίγραφό τους, στο fork με execv έπρεπε απλά να τους περάσουμε σαν όρισμα στον πίνακα args.
Με αυτόν τον τρόπο μόνο ο γονέας θα διαχειριζόταν τα αρχεία.

# 3η Εργαστηριακή Άσκηση

Επεκτείνουμε το πρόγραμμα του Eρωτήματος 2 ώστε να δημιουργεί P διεργασίες παιδιά 
οι οποίες αναζητούν παράλληλα τον χαρακτήρα στο αρχείο.
Η γονεϊκή διεργασία συλλέγει και τυπώνει το συνολικό αποτέλεσμα. Επίσης,
όταν το πρόγραμμά δέχεται Control+C από το πληκτρολόγιο αντί να τερματίζει, τυπώνει το συνολικό αριθμό
διεργασιών που αναζητούν το αρχείο.

Το πρόγραμμά μας δέχεται 3 ορίσματα:
- Το αρχείο στο οποίο γίνεται η αναζήτηση
- Τον χαρακτήρα προς αναζήτηση
- Τον αριθμό P των διεργασιών-παιδιών

## Υπολογισμός μεγέθους αρχείου

Πρώτα βρίσκουμε το μέγεθος του αρχείου για να κατανείμουμε κατάλληλα τον φόρτο εργασίας σε κάθε παιδί.
```c
int fdr = open(argv[1], O_RDONLY | O_CREAT, 0666);	
if(fdr < 0){
	printf("Problem opening target file\n");
	return -1;
}	
int sz = lseek(fdr, 0, SEEK_END);
printf("Target file size: %d\n", sz);
close(fdr);	
```
Επίσης κλείνουμε το αρχείο καθώς στην παρούσα υλοποίηση οι διεργασίες δεν μοιράζονται file descriptors,
όπως θα εξηγήσουμε παρακάτω.

## Υπολογισμός φόρτου εργασίας για κάθε παιδί

Υπολογίζουμε τον αριθμό σε bytes τον οποίο πρέπει να διαβάσει κάθε παιδί. Αν ο αριθμός των παιδιών δεν δοθεί ως όρισμα,
χρησιμοποιούμε το 2 ως προεπιλογή.
```c
workers = (argv[3] == NULL ? 2 : atoi(argv[3]));	
int workerSz = sz / workers, rem = sz % workers;
printf("Assigning chunks of up to %d bytes to each worker\n", workerSz);
```

## Εγκατάσταση εξυπηρετητή σήματος SIGINT για τα παιδία

Έπειτα εγκαθιστούμε τον δικό μας άδειο signal handler του σήματος SIGINT για τα παιδιά, καθώς δεν θέλουμε να γίνεται
τίποτα όταν λαμβάνουν το σήμα.
```c
//block SIGINT for all processes
sigset_t block;
sigemptyset(&block);
sigaddset(&block, SIGINT);	
sigprocmask(SIG_BLOCK, &block, NULL);
```

Σημείωση:  Κάθε διεργασία που δημιουργείται με `fork`, αφού έχει εγκατασταθεί ο εξυπηρετητής, θα κληρονομήσει επίσης τον ίδιο εξυπηρετητή.
Οι εξυπηρετητές μεταβαίνουν στην προεπιλεγμένη συμπεριφορά τους μόνο αν μετά το fork κάνουμε execv, ή τους αλλάξουμε χειροκίνητα. 
Επίσης στη γενική περίπτωση αν στείλουμε σήμα SIGINT πριν την εγκατάσταση του εξυπηρετητή το πρόγραμμα θα εκτελέσει την προεπιλεγμένη λειτουργία, δηλαδή θα τερματίσει.

## Δημιουργία παιδιών και σωληνώσεων επικοινωνίας

```c
pid_t pid[workers];

int pipefd[workers][2];

int ind = 0, p = 1;
for(; ind < workers && p > 0; ind++){
	if(pipe(pipefd[ind]) == -1){
		printf("Error creating pipe for %d worker\n");
		p = -1;
	}	
	else{
		fcntl(pipefd[ind][0], F_SETFL, O_NONBLOCK);		
		p = fork();
		if(p > 0)
			pid[ind] = p;
	}	
}
if(p < 0){
	//only parent process will land here if "ind" child is not created successfully
	//children [0, ind-2] should terminate
	printf("Error creating worker %d, terminating the rest\n", ind);
	for(int i = 0; i < ind-1; i++)
		kill(pid[i], SIGTERM);
	return -1;
}

```

Αφού έχουμε εγκαταστήσει τον εξυπηρετητή προσπαθούμε να δημιουργήσουμε P παιδία και P pipes με τα οποία θα μπορούμε να λαμβάνουμε αποτελέσματα από αυτά.
Αν κάτι πάει λάθος, η μεταβλητή p θα λάβει αρνητική τιμή, το πρόγραμμα θα ενημερώσει τον χρήστη για το σφάλμα και θα τερματίσει όλες τις διεργασίες που έχουν ήδη δημιουργηθεί.

Με την κλήση συστήματος pipe δημιουργούμε έναν buffer, τον οποίο διαχειρίζεται το λειτουργικό, ο οποίος επιτρέπει εγγραφή πληροφοριών στο ένα άκρο του (από μια διεργασία) και ανάγνωση της πληροφορίας από το άλλο άκρο του (από μια άλλη διεργασία)
Ο descriptor `pipefd[ind][0]` αντιστοιχεί στο άκρο ανάγνωσης, τον οποίο χρησιμοποιεί ο γονέας για τον έλεγχο των αποτελεσμάτων των παιδιών και ο 
descriptor `pipefd[ind][1]` αντιστοιχεί στο άκρο εγγραφής, τον οποίο χρησιμοποιούν τα παιδία για την εκτύπωση των αποτελεσμάτων.

Εφόσον δεν γνωρίζουμε πότε κάθε παιδί θα εκτυπώσει το αποτέλεσμα του στο pipe, θα θέλαμε ο γονέας να μην περιμένει (block) όταν το pipe είναι άδειο μέχρι να σταλθεί κάποια πληροφορία, ώστε να μπορεί να συνεχίσει με άλλες εργασίες.
Για αυτόν τον λόγο χρησιμοποιούμε την κλήση συστήματος `fcntl(pipefd[ind][0], F_SETFL, O_NONBLOCK);` η οποία δεν "μπλοκάρει" το άκρο ανάγνωσης αν το pipe είναι άδειο.

Τέλος, με την κλήση συστήματος `fork()` δημιουργούμε αλυσιδωτά τα παιδιά (το ένα παιδί δημιουργεί το άλλο) και αποθηκεύουμε το process id τους στον πίνακα `pid`.

## Βρισκόμαστε σε κάποιο από τα παιδιά (p==0)
```c
else if(p == 0){
		int i = ind-1;
		//only child/worker will land here
		printf("Worker %d: Starting\n", ind);
		//close ununsed (by child) reading end of pipe
		close(pipefd[i][0]);	
		//block SIGINT
		//sigprocmask(SIG_BLOCK, &block, NULL);
	
		//create new file descriptor
		fdr = open(argv[1], O_RDONLY, 0666);	
		if(fdr < 0){
			printf("Worker %d could not open target file\n", ind);
			return -1;
		}	

		//deterimine starting and ending positions (inclusive)
		int startPos, endPos;
		if(i < rem){
			startPos = i * (workerSz+1);
			endPos = startPos + workerSz;
		}
		else{
			startPos = rem + i * workerSz;
			endPos = startPos + workerSz - 1;
		}
		int ans = 0;
		char buff[BATCH_SIZE];

		//set fd offset to startPos
		lseek(fdr, startPos, SEEK_SET);

		for(int curPos = startPos; curPos <= endPos;){	
			int readSz = min(BATCH_SIZE, endPos - curPos + 1);	
			read(fdr, buff, readSz);
			usleep(SLEEP_DURATION);
			curPos += readSz;			

			for(int i = 0; i < readSz; i++)
				ans += buff[i] == argv[2][0]; 
		} 		
		close(fdr);

		//write result to pipe
		write(pipefd[i][1], &ans, sizeof(int));
		close(pipefd[i][1]);
		printf("Worker %d: Done\n", ind);		

		return 0;
	}
```

Για καλή πρακτική κλείνουμε το άκρο ανάγνωσης που χρησιμοποιεί μόνο ο γονέας. Έπειτα ανοίγουμε έναν καινούργιο file descriptor για το αρχείο μας, βρίσκουμε το κομματί που πρέπει να διαβάσουμε και μετακινούμε τον δείκτη ανάγνωσης σε εκείνο το σημείο με την εντολή `lseek`.
Έπειτα διαβάζουμε το κομμάτι του αρχείου που μας αντιστοιχεί σε κομμάτια των `BATCH_SIZE`, μετράμε τις εμφανίσεις του ζητούμενου χαρακτήρα, εκτυπώνουμε το αποτέλεσμα στο άκρο εγγραφής του pipe και τερματίζουμε. Ας σημειωθεί πως εφόσον η δημιουργία των παιδιών γίνεται αλυσιδωτά, η μεταβλητή ind ανανεώνεται σωστά, οι αναφορές στα pipes είναι και αυτές σωστές.

Χρήση διαφορετικoύ file descriptor σε κάθε παιδί έναντι διαμοιρασμού κοινού file descriptor:
Θα μπορούσαμε να χρησιμοποιήσουμε έναν κοινό fdr για όλα τα παιδιά αν χρησιμοποιούσαμε μόνο την εντολή `read` καθώς το λειτουργικό 
εξασφαλίζει την ατομική λειτουργία της. Όμως με αυτήν την υλοποίηση δεν θα είχαμε έλεγχο στο ποιο κομμάτι του αρχείου θα διάβαζε κάθε παιδί, καθώς δεν θα μπορούσαμε
να χρησιμοποιήσουμε την εντολή `lseek`, η οποία δεν εκτελείται ατομικά σε συνδυασμό με την `read`. Για αυτόν τον λόγο επιλέξαμε κάθε παιδί να έχει τον δικό του fdr.

## Βρισκόμαστε στον γονέα (p == κάποιο pid)
```c
else{
		//only parent process will land here if all children are created successfully
		active = workers;
		printf("Successfully created %d workers\n", workers);
		//wait for all children to finish and report result
		//if one child fails remember it, after all finish, report it
		int tot = 0;
		bool ok = 1;	
	
		struct sigaction slog;
		slog.sa_handler = handler;
		slog.sa_flags = 0;
		sigemptyset(&slog.sa_mask);
		sigaction(SIGINT, &slog, NULL);		
	
		while(active > 0){
			for(int i = 0; i < workers; i++){
				if(done[i])
					continue;		
				int wstatus;
				sigprocmask(SIG_BLOCK, &block, NULL);
				pid_t pdone = waitpid(pid[i], &wstatus, WNOHANG);
				sigprocmask(SIG_UNBLOCK, &block, NULL);	
				
				if(pdone == pid[i]){
					int res;
					int sz = read(pipefd[i][0], &res, sizeof(int));
					if(sz > 0){
						close(pipefd[i][0]); 	
						printf("Worker (%d): Successfully accounted\n", i+1);
						tot += res;
					}
					else{
						printf("Worker (%d): Failed\n", i+1);
						ok = 0;
					}
					done[i] = 1;
					active--;
				} else if (pdone == -1) {
						printf("Worker (%d): Failed\n", i+1);
						ok = 0;
					}
				}
			}
		}

		if(!ok) printf("Cannot provide final result because some worker failed\n");
		else printf("Final result: %d\n", tot);
	}
```

Το πρώτο πράγμα που κάνουμε στον γονέα είναι να εγκαταστήσουμε τον εξυπηρετητή που εκτυπώνει τον αριθμό των ενεργών παιδιών.
Έπειτα, διατρέχουμε όλα τα παιδιά και περιμένουμε (non blocking) μέχρι κάποιο να τερματίσει με την κλήση `waitpid`. Αν τερμάτισε, δηλαδή `pdone==pid`, καταγράφουμε το αποτέλεσμα και μαρκάρουμε το παιδί για να μην χρειαστεί να το ξαναελέγξουμε `done[i]==1`, επίσης μειώνουμε τα ενεργά παιδιά κατά ένα `active--;`.
Αν υπάρχει κάποιο σφάλμα, δηλαδή `pdone == -1` ή `sz==0`, ενημερώνουμε τον χρήστη. Αν όλα πάνε καλά, και τερματίσει το τελευταίο ενεργό παιδί, εκτυπώνουμε το συνολικό αποτέλεσμα.

Ας σημειωθεί πως όταν περιμένουμε για κάποιο παιδί να τερματίσει με την κλήση `waitpid`, απενεργοποιούμε τον signal handler του SIGINT, 
καθώς αν συνέπεφτε το SIGINT την ώρα που εκτελούσαμε την κλήση waitpid, αυτή θα επέστρεφε -1, το οποίο θα μπορούσαμε να διαχειριστούμε κοιτώντας αν `errno == EINTR`. Για ευκολία όμως επιλέξαμε να απενεργοποιήσουμε προσωρινά τον signal handler.

## 4η Εργαστηριακή Άσκηση

### worker.c

Ο πυρήνας του αρχείου worker.c για την καταμέτρηση χαρακτήρα σε ένα διάστημα βασίζεται στην άσκηση *1.3*. 

Σχετικά με την επικοινωνία του με τον πατέρα/dispatcher:

Θέλουμε ο κώδικας του worker.c να εκτελείται μετά την χρήση `execv()`, για αυτό η συνάρτηση main χρειάστηκε να δέχεται τις εξής 6 παραμέτρους
 
- Το worker id του (μπορεί να παραλειφθεί)
- Το όνομα του αρχείου που θέλουμε να διαβάσουμε 
- Την θέση του πρώτου byte που θέλουμε να επεξεργαστούμε
- Την θέση του τελευταίου byte
- Τον χαρακτήρα που μετράμε
- Το file descriptor του pipe όπου θα γράψουμε το αποτέλεσμα

Για την επικοινωνία μεταξύ των workers και του dispatcher αποφασίσαμε να χρησιμοποιήσουμε ένα ξεχωριστό pipe για κάθε worker. Ο εργάτης θα στέλνει μέσω αυτού το τελικό αποτέλεσμα αλλά και οποιδήποτε ενδιάμεσο αποτέλεσμα όταν του ζητηθεί.

Αποφύγαμε την χρήση κοινού pipe για την εγγραφή διότι:
- Είναι λίγο πιο δύσκολο να καταλάβουμε από ποιόν worker προήλθε το κάθε αποτέλεσμα
- Είχαμε ανησυχίες για την εμφάνηση συνθήκων συναγωνισμού όταν δύο εργάτες προσπαθούν ταυτόχρονα να γράψουν στο κοινό pipe (Αργότερα μάθαμε ότι εφαρμόζονται κατάλληλα κλειδώματα ώστε να μην εμφανίζεται αυτό το πρόβλημα)

Το κύριο πλεονέκτημα χρήσης κοινού pipe είναι ότι αυξάνεται σημαντικά ο αριθμός των μέγιστων εργατών που μπορούν να χρησιμοποιηθούν. Σε αυτή την έκδοση ο μέγιστος αριθμός εργατών είναι περίπου 1000 λόγω του ορίου στον αριθμό ανοιχτών file descriptor.

Για να μην είναι απαραίτητη η τελευταία παράμετρος χρησιμοποιήσαμε πρωτού εκτελέσουμε execv() την εντολή `dup2(workHead->pipefd[1], STDOUT_FILENO);` η οποία αντικαθηστά το stdout του αρχείου με το fd του κατάλληλου pipe. Προσέχουμε να μην χρησιμοποιούμε πλέον το stdout για την αναφορά λαθών

Για την αναφορά ενδιάμεσων αποτελεσμάτων χρησιμοποιήσαμε σήματα από τον dispatcher στους workers. Όταν ένας worker δεχτεί σήμα `SIGUSR1` σταματάει για λίγο να επεξεργάζεται χαρακτήρες και στέλνει 2 ακεραίους στον σωλήνα του: `write_to_pipe(cur-1, cnt);`

- Την θέση του τελευταίου byte που έχει ελέγξει
- Το πλήθος των χαρακτήρων που έχουν βρεθεί ως τώρα

Τέλος, ο αφότου τελειώσει την δουλεία του, ο εργάτης στέλνει μια τελική αναφορά `write_to_pipe(endPos, cnt);`

### dispatcher.c

Κύριος ρόλος του dispatcher είναι ο αποδοτικός διαμοιρασμός της συνολικής δουλειάς. Το πρόβλημα της προσέγγισης που χρησιμοποιήσαμε στην άσκηση *1.3* είναι ότι δεν είναι δυναμική, δηλαδή δεν υποστηρίζει κατάλληλα την προσθήκη και αφαίρεση εργατών.

Η λογική που τελικά ακολουθήσαμε είναι: Αν δεν έχει προκύψει κάποιο πρόβλημα αναθέτουμε σε έναν εργάτη που δεν έχει δουλειά το πρώτο διαθέσιμο κομμάτι μεγέθους `normalWLoad` bytes (πολλαπλάσιο του `CHUNK_SIZE`). Διατηρούμε λοιπόν ένα σύνορο (`front`) δεξιά του οποίου δεν εργάζεται κανένας worker ώστε όταν ελευθερωθεί κάποιος να αναλάβει το διάστημα `[front, front+normalWLoad-1]`. 

Αν όμως κάποιος εργάτης αποτύχει, δημιουργείται μία "τρύπα" στην επεξεργασία του αρχείου την οποία χρειάζεται να γεμίσει ο επόμενος εργάτης. Έλεγχουμε λοιπόν κατάλληλα για κάθε εργάτη αν έχει τερματίσει, αν τερμάτισε πρωτού τυπώσει το τελικό του αποτέλεσμα, κάτι πήγε στραβά, για αυτό κοιτάμε την τελευταία αναφορά που δεχτήκαμε από τον εργάτη (αν υπάρχει) και αποθηκεύουμε το διάστημα για το οποίο δεν έχει ενημερωθεί ο dispatcher, ώστε να το αναλάβει κάποιος επόμενος εργάτης

Αποφασίσαμε να χρησιμοποιήσουμε διπλά συνδεδεμένες λίστες για την αποθήκευση των εργατών που (απ'όσο ξέρει ο dispatcher) αυτή την στιγμή δουλεύουν και για τα διαστήματα που χρωστάμε να αναπληρώσουμε

Εκ των υστέρων, η επιλογή doubly linked list έναντι ενός στατικού array με κάποια μέγιστη χωρητικότητα ίσως ήταν υπερβολική αφού λόγω του ορίου στον μέγιστο αριθμό pipes, δεν μπορούμε να χρησιμοποιησουμε περισσότερους από 1000 εργάτες. Ωστόσο η υλοποιησή με linked list είναι αρκετά πιο ευέλικτη αφου μπορεί να υποστηρίξει αποδοτικά περισσότερους εργάτες αν αυξηθεί το μέγιστο όριο.

Για τον συνεχόμενο έλεγχο των εργατών και των σωλήνων τους από τον dispatcher χρησιμοποιήσαμε **non-blocking** `pid_t p = waitpid(cur->pid, &status, WNOHANG);`  και `read()`: με την εντολή `fcntl(workHead->pipefd[0], F_SETFL, O_NONBLOCK);` μετά την δημιουργία κάθε pipe. Ο έλεγχος εκτελείται σε ένα loop που τερματίζει μόνο όταν ολοκληρωθεί η επεξεργασία του αρχείου `while(proc < fileSz || workerCount > 0)`

Για την λήψη εντολών από το frontend: Στον κεντρικό βρόγχο ελέγχεται επίσης με non-blocking read() αν εκρεμεί κάποια εντολή από τον frontend `while(read(STDIN_FILENO, req, sizeof(req)) > 0)`

- Για την προσθήκη n εργατών: Καλείται n φορές η συνάρτηση `createWorker()` η οποία αν υπάρχει δουλειά να ανατεθεί και αν δεν υπερβαίνουμε τον μέγιστο αριθμό εργατών, κοιτάμε αν υπάρχει καποιο κενό που χρειάζεται να γεμίσουμε αλλιώς


O dispatcher δεν χρειάζεται να ειναι αποδοτικός

## frontend.c

Ο frontend λειτουργεί ως εξής:
- Αξιολογεί την εγκυρότητα των ορισμάτων που του δίνονται (αρχείο ανάγνωσης και χαρακτήρας προς καταμέτρηση)
- Δημιουργεί τον dispatcher με `fork` και `execv` δίνοντας του τα κατάλληλα ορίσματα και μεταφέροντας την έξοδό του στον ίδιο descriptor με το frontend (για ευκολία εκτύπωσης αποτελεσμάτων)
- Διαβάζει συνεχώς από το πληκτρολόγιο μέχρι να αναγνωρίσει μια έγκυρη εντολή, την οποία έπειτα διαβιβάζει στον dispatcher
μέσω ενός pipe.

Οι εντολές που αναγνωρίζει ο frontend έχουν δομή (string int) και ορίζονται στο αρχείο config.h. 
Έτσι κανείς μπορεί να προσθέσει εντολές στο πρόγραμμα με modular τρόπο. 
Για παράδειγμα, στη μια από τις 2 υλοποίησεις της άσκησης 4 που παραθέτουμε, 
η εντολή show 0 δείχνει μια μπάρα προόδου η οποία ανανεώνεται αυτόματα και αντιστοιχεί στο συνολικό ποσοστό 
καταμέτρησης σε όλο το αρχείο. Αντίστοιχα υπάρχει και η εντολή show 1 η οποία δημιουργεί τόσες μπάρες 
όσο και οι εργάτες, οι οποίες δείχνουν την ατομική πρόοδό τους και επίσης ανανεώνονται αυτόματα. 
Ο συνδυασμός show x, όπου x οποιοσδήποτε άλλος αριθμός καθαρίζει την οθόνη και ελαφρύνει το πρόγραμμα από 
τον φόρτο της εκτύπωσης και της διαρκούς ζήτησης αποτελεσμάτων από τον dispatcher προς τους workers. 
