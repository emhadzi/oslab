## 1 Συγχρονισμός σε υπάρχοντα κώδικα

Δημιουργούμε δύο νήματα εκ των οποίων το ένα αυξάνει τη τιμή της μεταβλητής *val* N φορές κατά 1 ενώ το δεύτερο τη μειώνει Ν φορές κατά 1.
Παρατηρούμε πως στη λήξη του προγράμματος η κοινή μεταβλητή *val* δεν διατηρεί την αρχική της τιμή (0). Αντιθέτως το αποτέλεσμα είναι μη ντετερμινιστικό 
και κυμαίνεται σε σφάλμα, το οποίο όμως δεν μπορεί να ξεπεράσει το έυρος [-Ν, Ν]. Η συμπεριφορά αυτή είναι λογική, εφόσον δεν υπάρχει συγχρονισμός, καθώς 
η αύξηση της τιμής μιας μεταβλητής (κατά 1) δεν είναι ατομική. Συγκεκριμένα ακολουθεί τα παρακάτω βήματα

1. Ανάγνωση της τιμής της val σε κάποιον καταχωρητή
2. Αύξηση του καταχωρητή κατά ένα
3. Αποθήκευση του καταχωρητή στη μνήμη

(Σημείωση, σε αρχιτεκτονικές CISC, η ανάγνωση και αύξηση μπορεί να γίνονται σε μία εντολή)

Αντίστοιχα βήματα ακολουθεί και η μείωση μιας μεταβλητής κατά 1, η οποία αντιστοίχως δεν είναι ατομική.

Από τα παραπάνω βλέπουμε πως αν ένα νήμα διαβάσει και επεξεργαστεί την τιμή val πρωτού ολοκληρωθεί η τελευταία αποθήκευση, τότε το αποτέλεσμα θα είναι λανθασμένο αφού το νήμα το οποίο θα
εκτελέσει τη τελευταία αποθήκευση στη μνήμη θα επεγγράψει την επεξεργασία του άλλου νήματος. Ο μόνος τρόπος να αποφευχθεί αυτό είναι να εξασφαλισούμε πως μόνο ένα νήμα
τη φορά μπορεί να επεξεργάζεται και να αποθηκεύει τη μεταβλητή ώστε το επόμενο νήμα να είναι σίγουρο πως θα διαβάσει την έγγυρη-επεξεργασμένη τιμή της. Πρέπει δηλαδή να εξασφαλίσουμε πως στο κρίσιμο τμήμα του κώδικα μας (εντολές 1, 2, 3) εισέρχεται μόνο ένα νήμα, ή να εξασφαλίσουμε πως αυτές δρουν ατομικά "ως πακέτο", δηλαδή δεν διακόπτονται ή εκτελούνται ταυτόχρονα.

### Συγχρονισμός με atomic και mutexes, local και oslab

`time ./simplesync-atomic (local)`
```
real    0m0,149s
user    0m0,273s
sys     0m0,002s
```
- Χρόνος χρήστη > πραγματικός χρόνος: Τα νήματα εκτελούνται σε διαφορετικούς πυρήνες
- Χρόνος συστήματος κοντά στο 0: Δεν υπάρχει ανάγκη για συγχρονισμό

`time ./simplesync-mutex (local)`
```
real    0m0,999s
user    0m1,348s
sys     0m0,583s
```

- Χρόνος συστήματος != 0: Σημαντικός χρόνος δαπανάται σε κατάσταση πυρήνα για συγχρονισμό
- Πραγματικός χρόνος mutex > πραγματικός χρόνος atomic: Αναμενόμενο
- Χρόνος χρήστη + χρόνος συστήματος = 2*πραγματικός χρόνος: Εκτέλεση σε 2 πυρήνες

`time ./simplesync-atomic (oslab)`
```
real	0m1,603s
user	0m0,335s
sys	0m0,017s
```

`time ./simplesync-mutex (oslab)`
```
real	0m5,641s
user	0m1,088s
sys	0m0,142s
```

- Πραγματικός χρόνος > χρόνος χρήστη + χρόνος συστήματος: Λόγω της κοινής χρήσης πόρων μεταξύ πολλαπλών χρηστών
- Οι χρόνοι χρήστη είναι περίπου ίδιοι με τους τοπικούς, αναμενόμενο
- Οι χρόνοι συστήματος είναι λίγο διαφορετικοί:
  - Μη μηδενικός για atomic, ίσως κάποια αναπόφευκτη επιβάρυνση για τη μεταβίβαση ελέγχου μεταξύ διαφορετικών χρηστών
  - Σχετικά μικρότερος για mutex: Ίσως όχι τόσο συχνά υποχρεωτικά content switches (timeouts)


### Απαντήσεις στις ερωτήσεις

1. Παρατηρούμε πως οι χρόνοι εκτέλεσης *Τ* των εκτελέσιμων ακολουθούν τη διάταξη <strong>T<sub>no sync</sub></strong> < <strong>T<sub>atomic</sub></strong> < <strong>T<sub>mutexes</sub></strong>. Η διαφορά μεταξύ του ασυγχρόνιστου εκτελέσιμου και αυτού με συγχρονισμού με ατομικές εντολές είναι μικρή, καθώς ο φόρτος των busy waits (δες παρακάτω) για την ατομική άθροιση-αφαίρεση είναι αμελητέος για μικρά Ν. Αντίθετα η διαφορά μεταξύ του εκτελέσιμου με ατομικές εντολές και αυτού με mutexes είναι μεγάλη, καθώς το δεύτερο οδηγεί σε πολλά περισσότερα context switches (επίσης δες παρακάτω), τα οποία αυξάνουν τον χρόνο στο kernel και άρα τον χρόνο εκτέλεσης    

2. Παρατηρούμε πως ο συγχρονισμός με ατομικές εντολές είναι πολύ πιο γρήγορος σε σχέση με αυτών με mutexes. Αυτό προκύπτει από το γεγονός πως οι ατομικές εντολές δεν χρησιμοποιούν τον δρομολογητή για να επιτύχουν συγχρονισμό. Αντίθετα λειτουργούν απευθείας στο hardware, δεσμεύοντας ένα cache line μέχρι οσότου να ολοκληρωθεί το "πακέτο εντολών" το οποίο επεξεργάζεται το δεδομένο εκείνης της γραμμής. Αυτή η στρατηγική έχει δύο πλεονεκτήματα:

   - Δεν επιτρέπει στον χρονοδρομολογητή να διακόψει το "πακέτο" της ατομικής εντολής. 
   - Ενημερώνει τα άλλα νήματα που προσπαθούν να αναγνώσουν το cache line πως είναι δεσμευμένο, θέτοντάς τα σε μια κατάσταση busy wait χωρίς να εμπλέκεται το
λειτουγρικό.

   Έτσι αποφεύγονται αχρείαστα context switches (αφού το νήμα που περιμένει παραμένει σε κατάσταση busy wait) και το "κρίσιμο τμήμα" πάντα ολοκληρώνεται σε έναν κβαντοχρόνο χρονοδρομολόγησης, δηλαδή δεν μένει ποτέ μπλοκαρισμένο από μια διεργασία η οποία είναι σε κατάσταση αναμονής. Φυσικά, πιο σύνθετες επεξεργασίες δεδομένων δεν θα επωφελούνταν από τη χρήση ατομικών εντολών καθώς αυτές υποστηρίζουν μόνο χαμηλού επιπέδου εντολές (όπως η άθροιση), οι οποίες γίνονται τάξεις μεγέθους πιο γρήγορα σε σχέση με το ίδιο το context switch. Έτσι δικαιολογούνται οι επεξαργαστικοί κύκλοι που σπαταλώνται στο busy wait των υπόλοιπων διεργασιών-νημάτων που μοιράζονται τον πόρο, τα οποία δεν στέλνονται σε αναμονή όπως γίνεται με τα mutexes.

3. Για την συνάρτηση `increase_fn`, όταν υλοποιείται με atomic, εκτελούμε:

``` makefile
simplesync-atomic.s: simplesync.c
	$(CC) $(CFLAGS) -DSYNC_ATOMIC -S -g -o simplesync-atomic.s simplesync.c:
```

Στο αρχείο `simplesync-atomic.s` αναζητούμε την φράση `.loc 1 51` και βρίσκουμε τον παρακάτω κώδικα:

``` x86asm
	movq	%rdi, %rbx
	movl	$10000000, %eax
.L2:
	lock addl	$1, (%rbx)          
	subl	$1, %eax
	jne	.L2
```

Το `lock` prefix σε μία εντολή δηλώνει ότι "κλειδώνει" το cache line της κοινής L3 ώστε αν ένας άλλος επεξεργαστής επιχειρήσει να διαβάσει από την ίδια διεύθυνση μνήμης να αναγκαστεί να κάνει stall μέχρι να ξεκλειδώσει (προτόκολο MESI).

Προφανώς σε περίπτωση ενός πυρήνα (concurrency) δεν υπάρχει πρόβλημα αφου δεν μπορεί να πραγματοποιηθεί context switch στην μέση της εντολής

4.Για την συνάρτηση `increase_fn` με mutexes, με παρόμοιο τρόπο, βρίσκουμε τον παρακάτω κώδικα στο αρχείο `simplesync-mutex.s`:

```x86asm
movq	%rdi, %rbp
leaq	lock(%rip), %r12                ; Get the address of lock (&lock) into r12
movl	$10000000, %ebx                 ; Load immediate for remaining loop iterations
.L2:
	movq	%r12, %rdi                  ; Pass it as argument to pthread_mutex_lock
	call	pthread_mutex_lock@PLT      ; PLT for dynamic linking
	movl	0(%rbp), %eax               ; %eax = *ip
	movq	%r12, %rdi                  ; Pass &lock as argument for pthread_mutex_unlock
	addl	$1, %eax                    ; %eax++
	movl	%eax, 0(%rbp)               ; *ip = %eax
	call	pthread_mutex_unlock@PLT     
	subl	$1, %ebx                    
	jne	.L2
```

Το `pthread_mutex_lock` και `pthread_mutex_unlock` είναι οι συναρτήσεις που υλοποιούν τον συγχρονισμό με mutexes. Ο ορισμός τους μπορεί να βρεθεί στην dynamic library pthread (πιθανώς υλοποιούνται με ατομικές εντολές τύπου `test_and_set()`). 

Φαίνεται πως η χρήση mutexes απαιτεί σημαντικά περισσότερες εντολές και άρα περισσότερο χρόνο εκτέλεσης σε σχέση με τις ατομικές εντολές. 




