## 1 Συγχρονισμός σε υπάρχοντα κώδικα

Δημιουργούμε δύο νήματα εκ των οποίων το ένα αυξάνει τη τιμή της μεταβλητής *val* N φορές κατά 1 ενώ το δεύτερο τη μειώνει Ν φορές κατά 1.
Παρατηρούμε πως στη λήξη του προγράμματος η κοινή μεταβλητή *val* δεν διατηρεί την αρχική της τιμή (0). Αντιθέτως το αποτέλεσμα είναι μη ντετερμινιστικό 
και κυμαίνεται σε σφάλμα, το οποίο όμως δεν μπορεί να ξεπεράσει το έυρος [-Ν, Ν]. Η συμπεριφορά αυτή είναι λογική, εφόσον δεν υπάρχει συγχρονισμός, καθώς 
η αύξηση της τιμής μιας μεταβλητής (κατά 1) δεν είναι ατομική. Συγκεκριμένα ακολουθεί τα παρακάτω βήματα

1. Ανάγνωση της τιμής της val σε κάποιον καταχωρητή
2. Αύξηση του καταχωρητή κατά ένα
3. Αποθήκευση του καταχωρητή στη μνήμη

(Σημείωση, σε αρχιτεκτονικές CISC, η ανάγνωση και αύξηση μπορεί να γίνονται σε μία εντολή)

Αντίστοιχα βήματα ακολουθεί και η μείωση μιας μεταβλητής κατά 1, η οποία αντιστοίχως δεν είναι ατομική.

Από τα παραπάνω βλέπουμε πως αν ένα νήμα διαβάσει και επεξεργαστεί την τιμή val πρωτού ολοκληρωθεί η τελευταία αποθήκευση, τότε το αποτέλεσμα θα είναι λανθασμένο αφού το νήμα το οποίο θα
εκτελέσει τη τελευταία αποθήκευση στη μνήμη θα επεγγράψει την επεξεργασία του άλλου νήματος. Ο μόνος τρόπος να αποφευχθεί αυτό είναι να εξασφαλισούμε πως μόνο ένα νήμα
τη φορά μπορεί να επεξεργάζεται και να αποθηκεύει τη μεταβλητή ώστε το επόμενο νήμα να είναι σίγουρο πως θα διαβάσει την έγγυρη-επεξεργασμένη τιμή της. Πρέπει δηλαδή να εξασφαλίσουμε πως στο κρίσιμο τμήμα του κώδικα μας (εντολές 1, 2, 3) εισέρχεται μόνο ένα νήμα, ή να εξασφαλίσουμε πως αυτές δρουν ατομικά "ως πακέτο", δηλαδή δεν διακόπτονται ή εκτελούνται ταυτόχρονα.

### Συγχρονισμός με atomic και mutexes, local και oslab

`time ./simplesync-atomic (local)`
```
real....0m0,149s
user....0m0,273s
sys.....0m0,002s
```
- Χρόνος χρήστη > πραγματικός χρόνος: Τα νήματα εκτελούνται σε διαφορετικούς πυρήνες
- Χρόνος συστήματος κοντά στο 0: Δεν υπάρχει ανάγκη για συγχρονισμό

`time ./simplesync-mutex (local)`
```
real....0m0,999s
user....0m1,348s
sys.....0m0,583s
```

- Χρόνος συστήματος != 0: Σημαντικός χρόνος δαπανάται σε κατάσταση πυρήνα για συγχρονισμό
- Πραγματικός χρόνος mutex > πραγματικός χρόνος atomic: Αναμενόμενο
- Χρόνος χρήστη + χρόνος συστήματος = 2*πραγματικός χρόνος: Εκτέλεση σε 2 πυρήνες

`time ./simplesync-atomic (oslab)`
```
real....0m1,603s
user....0m0,335s
sys.....0m0,017s
```

`time ./simplesync-mutex (oslab)`
```
real....0m5,641s
user....0m1,088s
sys.....0m0,142s
```

- Πραγματικός χρόνος > χρόνος χρήστη + χρόνος συστήματος: Λόγω της κοινής χρήσης πόρων μεταξύ πολλαπλών χρηστών
- Οι χρόνοι χρήστη είναι περίπου ίδιοι με τους τοπικούς, αναμενόμενο
- Οι χρόνοι συστήματος είναι λίγο διαφορετικοί:
  - Μη μηδενικός για atomic, ίσως κάποια αναπόφευκτη επιβάρυνση για τη μεταβίβαση ελέγχου μεταξύ διαφορετικών χρηστών
  - Σχετικά μικρότερος για mutex: Ίσως όχι τόσο συχνά υποχρεωτικά content switches (timeouts)


### Απαντήσεις στις ερωτήσεις

1. Παρατηρούμε πως οι χρόνοι εκτέλεσης *Τ* των εκτελέσιμων ακολουθούν τη διάταξη <strong>T<sub>no sync</sub></strong> < <strong>T<sub>atomic</sub></strong> < <strong>T<sub>mutexes</sub></strong>. Η διαφορά μεταξύ του ασυγχρόνιστου εκτελέσιμου και αυτού με συγχρονισμό με ατομικές εντολές είναι μικρή, καθώς ο φόρτος των busy waits (δες παρακάτω) για την ατομική άθροιση-αφαίρεση είναι αμελητέος για μικρά Ν. Αντίθετα η διαφορά μεταξύ του εκτελέσιμου με ατομικές εντολές και αυτού με mutexes είναι μεγάλη, καθώς το δεύτερο οδηγεί σε πολλά περισσότερα context switches (επίσης δες παρακάτω), τα οποία αυξάνουν τον χρόνο στο kernel και άρα τον χρόνο εκτέλεσης.    

2. Παρατηρούμε πως ο συγχρονισμός με ατομικές εντολές είναι πολύ πιο γρήγορος σε σχέση με αυτών με mutexes. Αυτό προκύπτει από το γεγονός πως οι ατομικές εντολές δεν χρησιμοποιούν τον δρομολογητή για να επιτύχουν συγχρονισμό. Αντίθετα λειτουργούν απευθείας στο hardware, δεσμεύοντας ένα cache line μέχρι οσότου να ολοκληρωθεί το "πακέτο εντολών" το οποίο επεξεργάζεται το δεδομένο εκείνης της γραμμής. Αυτή η στρατηγική έχει δύο πλεονεκτήματα:

   - Δεν επιτρέπει στον χρονοδρομολογητή να διακόψει το "πακέτο" της ατομικής εντολής. 
   - Ενημερώνει τα άλλα νήματα που προσπαθούν να αναγνώσουν το cache line πως είναι δεσμευμένο, θέτοντάς τα σε μια κατάσταση busy wait χωρίς να εμπλέκεται το λειτουργικό.

   Έτσι αποφεύγονται αχρείαστα context switches (αφού το νήμα που περιμένει παραμένει σε κατάσταση busy wait) και το "κρίσιμο τμήμα" πάντα ολοκληρώνεται σε έναν κβαντοχρόνο χρονοδρομολόγησης, δηλαδή δεν μένει ποτέ μπλοκαρισμένο από μια διεργασία η οποία είναι σε κατάσταση αναμονής. Φυσικά, πιο σύνθετες επεξεργασίες δεδομένων δε θα επωφελούνταν από τη χρήση ατομικών εντολών καθώς αυτές υποστηρίζουν μόνο χαμηλού επιπέδου εντολές (όπως η άθροιση), οι οποίες εκτελούνται τάξεις μεγέθους πιο γρήγορα σε σχέση με το ίδιο το context switch. Έτσι δικαιολογούνται οι επεξεργαστικοί κύκλοι που σπαταλώνται στο busy wait των υπόλοιπων διεργασιών-νημάτων που μοιράζονται τον πόρο, τα οποία δε στέλνονται σε αναμονή όπως γίνεται με τα mutexes.

3. Για την συνάρτηση `increase_fn`, όταν υλοποιείται με atomic, εκτελούμε:
	
	``` makefile
	simplesync-atomic.s: simplesync.c
		$(CC) $(CFLAGS) -DSYNC_ATOMIC -S -g -o simplesync-atomic.s simplesync.c:
	```
	
	Στο αρχείο `simplesync-atomic.s` αναζητούμε την φράση `.loc 1 51` και βρίσκουμε τον παρακάτω κώδικα:
	
	``` x86asm
		movq	%rdi, %rbx
		movl	$10000000, %eax
	.L2:
		lock addl	$1, (%rbx)          
		subl	$1, %eax
		jne	.L2
	```
	
	Το `lock` prefix σε μία εντολή δηλώνει ότι "κλειδώνει" το cache line της κοινής L3 ώστε αν ένας άλλος επεξεργαστής επιχειρήσει να διαβάσει από την ίδια διεύθυνση μνήμης να αναγκαστεί να κάνει stall μέχρι να ξεκλειδώσει (προτόκολο MESI).
	
	Προφανώς σε περίπτωση ενός πυρήνα (concurrency) δεν υπάρχει πρόβλημα αφου δεν μπορεί να πραγματοποιηθεί context switch στην μέση της εντολής

4. Για την συνάρτηση `increase_fn` με mutexes, με παρόμοιο τρόπο, βρίσκουμε τον παρακάτω κώδικα στο αρχείο `simplesync-mutex.s`:
	
	```x86asm
	movq	%rdi, %rbp
	leaq	lock(%rip), %r12                ; Get the address of lock (&lock) into r12
	movl	$10000000, %ebx                 ; Load immediate for remaining loop iterations
	.L2:
		movq	%r12, %rdi                  ; Pass it as argument to pthread_mutex_lock
		call	pthread_mutex_lock@PLT      ; PLT for dynamic linking
		movl	0(%rbp), %eax               ; %eax = *ip
		movq	%r12, %rdi                  ; Pass &lock as argument for pthread_mutex_unlock
		addl	$1, %eax                    ; %eax++
		movl	%eax, 0(%rbp)               ; *ip = %eax
		call	pthread_mutex_unlock@PLT     
		subl	$1, %ebx                    
		jne	.L2
	```
	
	Το `pthread_mutex_lock` και `pthread_mutex_unlock` είναι οι συναρτήσεις που υλοποιούν τον συγχρονισμό με mutexes. Ο ορισμός τους μπορεί να βρεθεί στην dynamic library pthread (πιθανώς υλοποιούνται με ατομικές εντολές τύπου `test_and_set()`). 
	
	Φαίνεται πως η χρήση mutexes απαιτεί σημαντικά περισσότερες εντολές και άρα περισσότερο χρόνο εκτέλεσης σε σχέση με τις ατομικές εντολές. 

## 2 Παράλληλος υπολογισμός του συνόλου Mandelbrot

### Απαντήσεις στις ερωτήσεις

1. Για το σχήμα συγχρονισμού που χρησιμοποιούμε απαιτούνται *NTHREADS* σημαφόροι, δηλαδή όσα και τα νήματα στα οποία κατανείμεται
   ο φόρτος εργασίας. Αυτό συμβαίνει γιατί θέλουμε η εκτύπωση να γίνεται σειριακά, οπότε θέλουμε μόνο ένα νήμα τη φορά να βρίσκεται στο
   κρίσιμο τμήμα του κώδικα (κώδικας εκτύπωσης). Για να το εξασφαλίσουμε αυτό θα πρέπει κάθε νήμα να ανταποκρίνεται σε ένα μόνο post, δηλαδή
   χρειαζόμαστε για κάθε νήμα να υπάρχει ένας σημαφόρος.
2. (Απάντηση στην ερώτηση 4)
3. Για τον συγχρονισμό με conditional variables χρησιμοποιήσαμε επίσης *NTHREADS* εξ αυτών. Η μόνη διαφορά με τους σημαφόρους είναι πως
   αντί να κάνουμε post, στο οποίο ανταποκρίνεται μόνο το κατάλληλο νήμα, κάνουμε notify, στο οποίο επίσης ανταποκρίνεται μόνο το νήμα που
   ανεμένει το αντίστοιχο condition.

   Θα μπορούσαμε να χρησιμοποιήσουμε μόνο μια μεταβλητή για τον συγχρονισμό, η οποία θα έκανε notify_all όλα τα νήματα τα οποία μετέπειτα θα
   έλεγχαν αν ήταν η σειρά τους να εκτυπώσουν. Το πρόβλημα με αυτήν την υλοποίηση είναι πως για κάθε εκτύπωση θα έπρεπε να ξυπνήσουν όλα τα νήματα,
   οδηγώντας σε αχρείαστα context switches εφόσον όλα εκτός από ένα θα έμπαιναν απευθείας σε κατάσταση αναμονής.
4. Προφανώς, το κρίσιμο τμήμα πρέπει να περιλαμβάνει μόνο την εκτύπωση, αφού μόνο εκείνη χρειάζεται συγχρονισμό (σειριοποίηση).
   Αν το κρίσιμο τμήμα περιλάμβανε και τον υπολογισμό, αυτός θα γινόταν επίσης σειριακά και όχι παράλληλα. Τότε, το κόστος του
   συγχρονισμού θα αύξανε τον χρόνο εκτέλεσης σε σχέση με το αρχικό πρόγραμμα, το οποίο είναι επίσης σειριακό. Η επιτάχυνση την οποία μετρήσαμε
   εμείς, σε σχέση με τα νήματα, φαίνεται παρακάτω (για την υλοποίηση με σημαφόρους - αλλά και αυτή με conditional variables δίνει σχεδόν πανομοιότυπες μετρήσεις):
	
	Χρόνος εκτέλεσης σειριακού υπολογισμού (1 νήμα):

	```
   real....0m39,730s
   user....0m37,212s
   sys.....0m1,064s
 	```
 
	Χρόνος εκτέλεσης παράλληλου υπολογισμού (2 νήματα):

    ```
   real....0m23,268s
   user....0m40,353s
   sys.....0m1,206s
	```
   
   	Χρόνος εκτέλεσης παράλληλου υπολογισμού (3 νήματα):

    ```
   real....0m18,792s
   user....0m41,264s
   sys.....0m1,340s
    ```
	
	Χρόνος εκτέλεσης παράλληλου υπολογισμού (4 νήματα):

    ```
   real....0m11,755s
   user....0m40,238s
   sys.....0m1,597s
    ```

   	Χρόνος εκτέλεσης παράλληλου υπολογισμού (5 νήματα):

	```
   real....0m12,158s
   user....0m40,317s
   sys.....0m1,549s
    ```
 
	Παρατηρούμε πως ο χρόνος εκτέλεσης μειώνεται γραμμικά (προσεγγιστικά) με την αύξηση των νημάτων, μέχρι τα νήματα να φτάσουν να
ισούνται με τον αριθμό των επεξεργαστών που διαθέτουμε (4). Προσθέτοντας περισσότερα νήματα από τους επεξεργαστές δεν έχουμε παραλληλισμό
μεταξύ όλων των νημάτων, αφού κάποια δεν βρίσκουν διαθέσιμο πυρήνα για να εκτελεσθούν ταυτόχρονα. Έχουμε δηλαδή ταυτοχρονισμό, ή σειριακή εκτέλεση, 
η οποία λόγω του κόστους του συγχρονισμού οδηγεί σε αύξηση του συνολικού χρόνου εκτέλεσης. 

	Στην περίπτωση όπου ο αριθμός των νημάτων ισούνται ακριβώς με τον αριθμό επεξεργαστών (4 νήματα) βλέπουμε πως ισχύει προσεγγιστικά η σχέση:
 *real=(user+sys)/4*. Βλέπουμε δηλαδή πως ο φόρτος εργασίας κατανέμεται ισόποσα σε κάθε επεξεργαστή.


5. Το πρόγραμμα χρησιμοποιεί ANSI escape codes για να επεξεργαστεί τα χρώματα των χαρακτήρων που εκτυπώνονται. Τα ANSI escape codes αλληλεπιδρούν
   απευθείας με το τερματικό και διατηρούνται όσο αυτός είναι ανοιχτός, ανεξάρτητα από το αν η διεργασία που τα εκτύπωσε έχει ολοκληρωθεί. Για αυτόν
   τον λόγο εγκαταστήσαμε έναν signal handler ο οποίος φροντίζει να επαναφέρει τις ρυθμίσεις του τερματικού (με τα κατάλληλα escape codes), πρωτού το
   πρόγραμμα τερματίσει λόγω του σήματος SIGINT.

*Σημείωση:* Όπου ζητείται ο υπολογισμός του *mandelbrot* χρησιμοποιήσαμε την ανάλυση χαρακτήρων *x_char = 800*, *y_char = 400*, ώστε οι διαφορές των χρόνων εκτέλεσης να είναι περισσότερο διακριτές. 
