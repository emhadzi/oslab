## 1 Συγχρονισμός σε υπάρχοντα κώδικα

Δημιουργούμε δύο νήματα εκ των οποίων το ένα αυξάνει τη τιμή της μεταβλητής *val* N φορές κατά 1 ενώ το δεύτερο τη μειώνει Ν φορές κατά 1.
Παρατηρούμε πως στη λήξη του προγράμματος η κοινή μεταβλητή *val* δεν διατηρεί την αρχική της τιμή (0). Αντιθέτως το αποτέλεσμα είναι μη ντετερμινιστικό 
και κυμαίνεται σε σφάλμα, το οποίο όμως δεν μπορεί να ξεπεράσει το έυρος [-Ν, Ν]. Η συμπεριφορά αυτή είναι λογική, εφόσον δεν υπάρχει συγχρονισμός, καθώς 
η αύξηση της τιμής μιας μεταβλητής (κατά 1) δεν είναι ατομική. Συγκεκριμένα ακολουθεί τα παρακάτω βήματα

1. Ανάγνωση της τιμής της val σε κάποιον καταχωρητή
2. Αύξηση του καταχωρητή κατά ένα
3. Αποθήκευση του καταχωρητή στη μνήμη

(Σημείωση, σε αρχιτεκτονικές CISC, η ανάγνωση και αύξηση μπορεί να γίνονται σε μία εντολή)

Αντίστοιχα βήματα ακολουθεί και η μείωση μιας βεταβλητής κατά 1.

Από τα παραπάνω βλέπουμε πως αν ένα νήμα διαβάσει και επεξεργαστεί την τιμή val πρωτού ολοκληρωθεί η τελευταία αποθήκευση, τότε το αποτέλεσμα θα είναι λανθασμένο αφού το νήμα το οποίο θα
εκτελέσει τη τελευταία αποθήκευση στη μνήμη θα επεγγράψει την επεξεργασία του άλλου νήματος. Ο μόνος τρόπος να αποφευχθεί αυτό είναι να εξασφαλισούμε πως μόνο ένα νήμα
τη φορά μπορεί να επεξεργάζεται και να αποθηκεύει τη μεταβλητή ώστε το επόμενο νήμα να είναι σίγουρο πως θα διαβάσει την έγγυρη-επεξεργασμένη τιμή της. Πρέπει δηλαδή να εξασφαλίσουμε πως
στο κρίσιμο τμήμα του κώδικα μας (εντολές 1, 2, 3) εισέρχεται μόνο ένα νήμα, δηλαδή αυτές δρουν ατομικά "ως πακέτο".
