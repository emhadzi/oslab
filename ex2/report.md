## 1 Συγχρονισμός σε υπάρχοντα κώδικα

Δημιουργούμε δύο νήματα εκ των οποίων το ένα αυξάνει τη τιμή της μεταβλητής *val* N φορές κατά 1 ενώ το δεύτερο τη μειώνει Ν φορές κατά 1.
Παρατηρούμε πως στη λήξη του προγράμματος η κοινή μεταβλητή *val* δεν διατηρεί την αρχική της τιμή (0). Αντιθέτως το αποτέλεσμα είναι μη ντετερμινιστικό 
και κυμαίνεται σε σφάλμα, το οποίο όμως δεν μπορεί να ξεπεράσει το έυρος [-Ν, Ν]. Η συμπεριφορά αυτή είναι λογική, εφόσον δεν υπάρχει συγχρονισμός, καθώς 
η αύξηση της τιμής μιας μεταβλητής (κατά 1) δεν είναι ατομική. Συγκεκριμένα ακολουθεί τα παρακάτω βήματα

1. Ανάγνωση της τιμής της val σε κάποιον καταχωρητή
2. Αύξηση του καταχωρητή κατά ένα
3. Αποθήκευση του καταχωρητή στη μνήμη

(Σημείωση, σε αρχιτεκτονικές CISC, η ανάγνωση και αύξηση μπορεί να γίνονται σε μία εντολή)

Αντίστοιχα βήματα ακολουθεί και η μείωση μιας βεταβλητής κατά 1, η οποία αντιστοίχως δεν είναι ατομική.

Από τα παραπάνω βλέπουμε πως αν ένα νήμα διαβάσει και επεξεργαστεί την τιμή val πρωτού ολοκληρωθεί η τελευταία αποθήκευση, τότε το αποτέλεσμα θα είναι λανθασμένο αφού το νήμα το οποίο θα
εκτελέσει τη τελευταία αποθήκευση στη μνήμη θα επεγγράψει την επεξεργασία του άλλου νήματος. Ο μόνος τρόπος να αποφευχθεί αυτό είναι να εξασφαλισούμε πως μόνο ένα νήμα
τη φορά μπορεί να επεξεργάζεται και να αποθηκεύει τη μεταβλητή ώστε το επόμενο νήμα να είναι σίγουρο πως θα διαβάσει την έγγυρη-επεξεργασμένη τιμή της. Πρέπει δηλαδή να εξασφαλίσουμε πως στο κρίσιμο τμήμα του κώδικα μας (εντολές 1, 2, 3) εισέρχεται μόνο ένα νήμα, ή να εξασφαλίσουμε πως αυτές δρουν ατομικά "ως πακέτο", δηλαδή δεν διακόπτονται ή εκτελούνται ταυτόχρονα.

### Συγχρονισμός με atomic

-- TODO ADD PHOTOS AND TIMES ...

### Συγχρονισμός me mutexes

-- TODO ADD PHOTOS AND TIMES

### Απαντήσεις στις ερωτήσεις

1. Παρατηρούμε πως οι χρόνοι εκτέλεσης *Τ* των εκτελέσιμων ακολουθούν τη διάταξη <strong>T<sub>no sync</sub></strong> < <strong>T<sub>atomic</sub></strong> < <strong>T<sub>mutexes</sub></strong>. Η διαφορά μεταξύ του ασυγχρόνιστου εκτελέσιμου και αυτού με συγχρονισμού με ατομικές εντολές είναι μικρή, καθώς ο φόρτος των busy waits (δες παρακάτω) για την ατομική άθροιση-αφαίρεση είναι αμελητέος για μικρά Ν. Αντίθετα η διαφορά μεταξύ του εκτελέσιμου με ατομικές εντολές και αυτού με mutexes είναι μεγάλη, καθώς το δεύτερο οδηγεί σε πολλά περισσότερα context switches (επίσης δες παρακάτω), τα οποία αυξάνουν τον χρόνο στο kernel και άρα τον χρόνο εκτέλεσης    

2. Παρατηρούμε πως ο συγχρονισμός με ατομικές εντολές είναι πολύ πιο γρήγορος σε σχέση με αυτών με mutexes. Αυτό προκύπτει από το γεγονός πως οι ατομικές εντολές δεν χρησιμοποιούν τον δρομολογητή για να επιτύχουν συγχρονισμό. Αντίθετα λειτουργούν απευθείας στο hardware, δεσμεύοντας ένα cache line μέχρι οσότου να ολοκληρωθεί το "πακέτο εντολών" το οποίο επεξεργάζεται το δεδομένο εκείνης της γραμμής. Αυτή η στρατηγική έχει δύο πλεονεκτήματα:

   - Δεν επιτρέπει στον χρονοδρομολογητή να διακόψει το "πακέτο" της ατομικής εντολής. 
   - Ενημερώνει τα άλλα νήματα που προσπαθούν να αναγνώσουν το cache line πως είναι δεσμευμένο, θέτοντάς τα σε μια κατάσταση busy wait χωρίς να εμπλέκεται το
λειτουγρικό.

   Έτσι αποφεύγονται αχρείαστα context switches (αφού το νήμα που περιμένει παραμένει σε κατάσταση busy wait) και το "κρίσιμο τμήμα" πάντα ολοκληρώνεται σε έναν κβαντοχρόνο χρονοδρομολόγησης, δηλαδή δεν μένει ποτέ μπλοκαρισμένο από μια διεργασία η οποία είναι σε κατάσταση αναμονής. Φυσικά, πιο σύνθετες επεξεργασίες δεδομένων δεν θα επωφελούνταν από τη χρήση ατομικών εντολών καθώς αυτές υποστηρίζουν μόνο χαμηλού επιπέδου εντολές (όπως η άθροιση), οι οποίες γίνονται τάξεις μεγέθους πιο γρήγορα σε σχέση με το ίδιο το context switch. Έτσι δικαιολογούνται οι επεξαργαστικοί κύκλοι που σπαταλώνται στο busy wait των υπόλοιπων διεργασιών-νημάτων που μοιράζονται τον πόρο, τα οποία δεν στέλνονται σε αναμονή όπως γίνεται με τα mutexes.

3. TODO
4. TODO

   


